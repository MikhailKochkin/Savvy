import { useState, useEffect } from "react";
import { useMutation, gql } from "@apollo/client";
import styled from "styled-components";
import { useRouter } from "next/router";
import { BiMicrophone, BiMicrophoneOff } from "react-icons/bi";
import parse from "html-react-parser";
import { InfinitySpin, TailSpin } from "react-loader-spinner";
import { useTranslation } from "next-i18next";
import smoothscroll from "smoothscroll-polyfill";
import PropTypes from "prop-types";

import {
  guessAlphabet,
  autoResizeTextarea,
  removeSpecialChars,
} from "./quizFunctions";
import {
  IconBlock,
  Question,
  Answer_text,
  ResultCircle,
  Button1,
  Circle,
  Frame,
} from "./quizesStyles";

const CREATE_QUIZRESULT_MUTATION = gql`
  mutation CREATE_QUIZRESULT_MUTATION(
    $answer: String
    $quiz: String
    $lessonId: String
    $result: String
    $type: String
    $correct: Boolean
    $comment: String
    $hint: String
    $explanation: String
    $improvement: String
    $ideasList: QuizIdeas
  ) {
    createQuizResult(
      answer: $answer
      quiz: $quiz
      lessonId: $lessonId
      correct: $correct
      comment: $comment
      type: $type
      result: $result
      hint: $hint
      explanation: $explanation
      improvement: $improvement
      ideasList: $ideasList
    ) {
      id
    }
  }
`;

const Options = styled.div`
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
  width: 100%;
  margin-bottom: 20px;
`;

const Group = styled.div`
  flex-direction: row;
  justify-content: center;
  background: ${(props) => props.inputColor};
  width: 100%;
  pointer-events: ${(props) => (props.progress === "true" ? "none" : "auto")};
  display: ${(props) => (props.correct === "true" ? "none" : "flex")};
  padding: 0.5% 0;
  margin-bottom: 20px;
`;

const Group2 = styled.div`
  flex-direction: row;
  justify-content: flex-start;
  flex-wrap: wrap;
  background: ${(props) => props.inputColor};
  width: 90%;
  pointer-events: auto;
  display: flex;
  padding: 0.5% 0;
  margin-bottom: 20px;
`;

const Progress = styled.div`
  display: ${(props) => (props.display === "true" ? "flex" : "none")};
  flex-direction: row;
  justify-content: center;
  width: 100%;
  margin-bottom: 10px;
`;

const Progress2 = styled.div`
  display: flex;
  flex-direction: row;
  justify-content: center;
  width: 100%;
  margin: 10px;
`;

const OpenQuestion = (props) => {
  const { author, me, story, ifRight, ifWrong, quizId } = props;

  const [answer, setAnswer] = useState(""); // The answer provided by the student
  const [previousAnswers, setPreviousAnswers] = useState([]); // The answer provided by the student
  const [correct, setCorrect] = useState(""); // is the answer by the student correct? Used to communicate with the student
  const [correctnessLevel, setCorrectnessLevel] = useState(); // more deep understanding of the correctness. Used to generate prompts
  const [result, setResult] = useState(null); // student's grade

  const [hidden, setHidden] = useState(true); // is the answer to the question hidden?
  const [progress, setProgress] = useState("false");
  const [inputColor, setInputColor] = useState("#f3f3f3");
  const [isExperienced, setIsExperienced] = useState(false); // set to false once we get the student answer

  const [recognition, setRecognition] = useState(null); // used for voice recognition
  const [startSpeech, setStartSpeech] = useState(false); // used for voice recognition

  const [generating, setGenerating] = useState(false); // loading spinner when checking the student's answer
  const [hint, setHint] = useState(null); // give the hint to the student without the use of AI
  const [AIhint, setAIHint] = useState(""); // student's last hint generated by AI
  const [hints, setHints] = useState([]); // all AI generated hints

  const [generatingExplanation, setGeneratingExplanation] = useState(false); // loading new explanation
  const [explanations, setExplanantions] = useState([]); // all AI generated explanations
  const [explanationsNum, setExplanationsNum] = useState(0); // how many explanations the student asked for
  const [AIExplanation, setAIExplanation] = useState(""); // student's last explanation generated by AI

  const [generatingImprovement, setGeneratingImprovement] = useState(null); // loading new improvement
  const [improvementsNum, setImprovementsNum] = useState(0); // how many improvements the student asked for
  const [improvements, setImprovements] = useState([]); // all AI generated improvements
  const [AIImprovement, setAIImprovement] = useState(""); // student's last improvement generated by AI

  const { passResult } = props;
  const router = useRouter();

  const [createQuizResult, { data, loading, error }] = useMutation(
    CREATE_QUIZRESULT_MUTATION
  );

  useEffect(() => {
    // kick off the polyfill!
    smoothscroll.polyfill();
  });

  const { t } = useTranslation("lesson");

  const intro = `
      You are a law professor. You asked your student this question: """ ${props.question} """.
      You expect to recieve an answer that sounds like this (correct answer): """ ${props.answer} """.
    `;

  // 1. Check student's answer

  const onAnswer = async (e) => {
    setAIExplanation(null);
    setProgress("true");
    setExplanationsNum(0);
    setImprovementsNum(0);
    let data1 = {
      answer1: props.answer.toLowerCase(),
      answer2: answer.toLowerCase(),
    };
    setPreviousAnswers([...previousAnswers, answer]);
    if (props.check === "WORD") {
      if (props.answer.toLowerCase() === answer.toLowerCase()) {
        if (!isExperienced) {
          if (props.getResults) props.getResults(2);
          setIsExperienced(true);
        }
        setCorrect("true");
        if (props.goalType !== "ASSESS")
          setInputColor("rgba(50, 172, 102, 0.25)");
        passResult("true");
      } else {
        setCorrect("false");
        if (props.goalType !== "ASSESS")
          setInputColor("rgba(222, 107, 72, 0.5)");
        passResult("false");
      }
    } else {
      const r = await fetch(
        "https://arcane-refuge-67529.herokuapp.com/checker",
        {
          method: "POST", // or 'PUT'
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(data1),
        }
      )
        .then((response) => response.json())
        .then((res) => {
          determineCorrectness(res.res);
          if (parseFloat(res.res) > 65) {
            setCorrect("true");
            passResult("true");
            if (props.goalType !== "ASSESS") {
              setInputColor("rgba(50, 172, 102, 0.25)");
            }
            setResult(parseFloat(res.res));

            createQuizResult({
              variables: {
                quiz: props.quizId,
                lessonId: props.lessonId,
                answer: answer,
                correct: true,
                result: res.res,
                type: "answer",
                hint: AIhint,
                explanation: AIExplanation,
                improvement: AIImprovement,
                comment: `Result: ${parseFloat(res.res)}%`,
              },
            });
            setProgress("false");
          } else if (parseFloat(res.res) > 58 && parseFloat(res.res) < 60) {
            setCorrect("has_flaws");
            setResult(parseFloat(res.res));
            if (props.goalType !== "ASSESS") setInputColor("#ffd166");
            passResult("true");
            if (typeof res.comment === "string") {
              if (res.comment == "more_detailed_response_recommended") {
                setHint(t("more_detailed_response_recommended"));
              } else if (res.comment == "more_concise_response_recommended") {
                setHint(t("more_concise_response_recommended"));
              }
            }
            createQuizResult({
              variables: {
                quiz: props.quizId,
                lessonId: props.lessonId,
                answer: answer,
                correct: true,
                type: "answer",
                hint: AIhint,
                result: res.res,
                explanation: AIExplanation,
                improvement: AIImprovement,
                comment: `Looks true: ${parseFloat(res.res)}%`,
              },
            });

            setProgress("false");
          } else if (parseFloat(res.res) > 60 && parseFloat(res.res) <= 65) {
            setCorrect("looks_true");
            setResult(parseFloat(res.res));
            if (props.goalType !== "ASSESS") setInputColor("#ffd166");
            passResult("true");
            if (typeof res.comment === "string") {
              if (res.comment == "more_detailed_response_recommended") {
                setHint(t("more_detailed_response_recommended"));
              } else if (res.comment == "more_concise_response_recommended") {
                setHint(t("more_concise_response_recommended"));
              }
            }
            createQuizResult({
              variables: {
                quiz: props.quizId,
                lessonId: props.lessonId,
                answer: answer,
                correct: true,
                type: "answer",
                hint: AIhint,
                result: res.res,
                explanation: AIExplanation,
                improvement: AIImprovement,
                comment: `Looks true: ${parseFloat(res.res)}%`,
              },
            });

            setProgress("false");
          } else {
            setCorrect("false");
            setResult(parseFloat(res.res));
            if (props.goalType !== "ASSESS")
              setInputColor("rgba(222, 107, 72, 0.5)");
            if (typeof res.comment === "string") {
              if (res.comment == "more_detailed_response_recommended") {
                setHint(t("more_detailed_response_recommended"));
              } else if (res.comment == "more_concise_response_recommended") {
                setHint(t("more_concise_response_recommended"));
              }
            }
            createQuizResult({
              variables: {
                quiz: props.quizId,
                lessonId: props.lessonId,
                answer: answer,
                correct: false,
                hint: AIhint,
                type: "answer",
                result: res.res,
                explanation: AIExplanation,
                improvement: AIImprovement,
                comment: `Result: ${parseFloat(res.res)}%`,
              },
            });
            setProgress("false");
            passResult("false");
          }
        })
        .catch((err) => console.log(err));
    }
    // setProgress("false");
  };

  // 2. Determine the correctness of the student's answer

  const determineCorrectness = async (result) => {
    if (result < 40) {
      setCorrectnessLevel("completely_wrong");
    } else if (result >= 40 && result < 50) {
      setCorrectnessLevel("wrong");
    } else if (result >= 50 && result < 58) {
      setCorrectnessLevel("slightly_wrong");
    } else if (result >= 58 && result < 60) {
      setCorrectnessLevel("has_flaws");
    } else if (result >= 60 && result < 65) {
      setCorrectnessLevel("looks_true");
    } else if (result >= 65) {
      setCorrectnessLevel("correct");
    }
  };

  // 3. Provide hints to the student

  const getHint = async (event) => {
    event.preventDefault();
    setGenerating(true);
    let AItype = "claude";
    let url;
    let result;
    let hintPrompt;

    if (AItype == "claude") {
      url = "/api/generate2";
    } else {
      url = "/api/generate";
    }

    // Пока хорошие результаты только на example based hints.
    // Но можно еще подсказать, где найти ответ, если есть источник.

    let hintingMethods = [
      `Provide a detailed real-life situation that can help the student understand the problem.`,
      `Provide a short gentle subtle hint that will help the studnet look at the question from a different angle.`,
      `Say where the student can find the answer to the question: the law, caselaw, the textbook, the lecture, etc. Use this info to find the source: ${ifWrong}. PROVIDE INFORMATION ONLY ABOUT THE SOURCE.`,
      // `Start with one or more general premises and arrive at a specific conclusion that follows necessarily from those premises. Use this conclusion as a hint.`,
    ];

    if (hints[hints.length - 1] == "😔 I have no more hints..") {
      setGenerating(false);
      return;
    }

    if (hints.length >= hintingMethods.length) {
      setGenerating(false);
      setAIHint("I am out of hints.");
      setHints([...hints, "😔 I have no more hints.."]);
      return "I am out of hints.";
    }

    let hintIntro = `You are a law professor. You help your student answer this question ${props.question}.
      The correct answer is:  ${props.answer}`;

    let hintAnswerRecommendations = `Answer in ${
      router.locale == "ru" ? "Russian" : "English"
    }. Answer in second person. Limit your hint to 3 sentences.`;

    hintPrompt = `
      Give a hint to the student in a Socratic manner on what is the correct answer to help them answer the question. 
      Use this approach: ${hintingMethods[hints.length]}
      Do not use the words from the correct answer.`;

    try {
      const response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          prompt: hintIntro + hintPrompt + hintAnswerRecommendations,
        }),
      });

      if (response.status !== 200) {
        throw (
          (await response.json()).error ||
          new Error(`Request failed with status ${response.status}`)
        );
      }
      const data = await response.json();
      if (AItype == "claude") {
        result = data.result.content[0].text;
      } else {
        result = data.result.content;
      }
      if (result) {
        setAIHint(result);
        setHints([...hints, result]);
        setGenerating(false);
        return result;
      } else {
        setAIHint("Sorry, you are on your own");
        setGenerating(false);
        return "Sorry, you are on your own";
      }
    } catch (error) {
      console.error(error);
      alert(error.message);
    }
  };

  // 4. Explain what is wrong with the answer based on the score of the student's answer

  const getExplanation = async (event) => {
    event.preventDefault();
    setGeneratingExplanation(true);
    let AItype = "claude";
    let url;
    let result;
    let proportion = ((answer.length / props.answer.length) * 100).toFixed(0);
    if (AItype == "claude") {
      url = "/api/generate2";
    } else {
      url = "/api/generate";
    }
    if (explanationsNum > 1) {
      setGeneratingExplanation(false);
      // setAIExplanation(
      //   "Please try answering the question before asking for more explanations."
      // );
      setExplanantions([
        ...explanations,
        "Please try answering the question before asking for more explanations.",
      ]);
      return;
    }

    let explanationRecommendations = `Write in second person. Address the student as "you".
      DO NOT USE the words from the correct answer!!! DO NOT REVEAL THE CORRECT ANSWER!!!
      Be very polite and gentle.
      Return your response with every paragrpah wrapped in <p> tags.
      Answer in ${router.locale == "ru" ? "Russian" : "English"}
      Make the answer at least 2 sentences long.`;

    if (proportion < 25 && explanations.length == 0) {
      let too_short_prompt = `
        The student's answer is too short. It is only """ ${proportion} """ of the sample correct answer.
        Check it: """ ${answer} """  
        If the answer is just a blob (like this: "test", "sdfsdfsfd", "answer", "..") and has no meaning, 
        politely say that this answer does not mean anything and ask the student to give a real answer.
        If the answer is meaningful, then just ask the student to provide more details.
        
      `;

      try {
        const response = await fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            prompt: too_short_prompt + explanationRecommendations,
          }),
        });

        if (response.status !== 200) {
          throw (
            (await response.json()).error ||
            new Error(`Request failed with status ${response.status}`)
          );
        }
        const data = await response.json();
        if (AItype == "claude") {
          result = data.result.content[0].text;
        } else {
          result = data.result.content;
        }
        if (result) {
          setAIExplanation(result);
          setExplanantions([...explanations, result]);
          setGeneratingExplanation(false);
          createQuizResult({
            variables: {
              quiz: props.quizId,
              lessonId: props.lessonId,
              answer: answer,
              type: "explanation",
              correct: false,
              hint: AIhint,
              explanation: result,
              improvement: AIImprovement,
              comment: `Student asked for explanations`,
            },
          });

          return result;
        } else {
          setAIExplanation("Sorry, you are on your own");
          setGeneratingExplanation(false);

          return "Sorry, error";
        }
      } catch (error) {
        setGeneratingExplanation(false);

        console.error(error);
        alert(error.message);
      }

      let simpleExplanation = t("more_detailed_response_recommended");
      // setAIExplanation(simpleExplanation);
      setExplanantions([...explanations, simpleExplanation]);
      createQuizResult({
        variables: {
          quiz: props.quizId,
          lessonId: props.lessonId,
          answer: answer,
          type: "explanation",
          correct: false,
          hint: AIhint,
          explanation: simpleExplanation,
          improvement: AIImprovement,
          comment: `Student asked for explanations`,
        },
      });
      setGeneratingExplanation(false);
      return simpleExplanation;
    }
    let explanantionPrompt;

    if (correctnessLevel == "completely_wrong" || correctnessLevel == "wrong") {
      explanantionPrompt = `
      But your student gave you a completely wrong answer: """ ${answer} """.
      Use:
      1) information about the correct answer 
      2) and information from the lesson: """ ${ifWrong} """
      3) Previous explanations: """ ${explanations.join(" ")} """
      
      to explain in 3 sentences why this answer is wrong. Make this explanantion more deatiled than the previous one.
      Do it in the following way:

      Explain what information must be in the question.
      Give recommendations on how to start the answer.

      Return every point as a separate <p> tag
      `;
    } else {
      explanantionPrompt = `
      But your student gave you a slightly wrong answer: """ ${answer} """.
      Use the information about the correct answer and information from the lesson: """ ${props.ifRight} """ to
      explain in 3 sentences how to make this answer correct. Do it in the following way:

      Explain which part of the answer does not look right and needs to be changed.
      Give recommendations on how to change this part of the answer.`;
    }
    try {
      const response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          prompt: intro + explanantionPrompt + explanationRecommendations,
        }),
      });

      if (response.status !== 200) {
        throw (
          (await response.json()).error ||
          new Error(`Request failed with status ${response.status}`)
        );
      }
      const data = await response.json();
      if (AItype == "claude") {
        result = data.result.content[0].text;
      } else {
        result = data.result.content;
      }
      if (result) {
        setExplanantions([...explanations, result]);
        setAIExplanation(result);
        setGeneratingExplanation(false);
        createQuizResult({
          variables: {
            quiz: props.quizId,
            lessonId: props.lessonId,
            answer: answer,
            type: "explanation",
            correct: false,
            hint: AIhint,
            explanation: result,
            improvement: AIImprovement,
            comment: `Student asked for explanations`,
          },
        });

        return result;
      } else {
        setAIExplanation("Sorry, you are on your own");
        setGeneratingExplanation(false);

        return "Sorry, error";
      }
    } catch (error) {
      setGeneratingExplanation(false);

      console.error(error);
      alert(error.message);
    }
  };

  // 5. Explain how to improve existing answer to get a higher score

  const getImprovements = async (event) => {
    event.preventDefault();
    setGeneratingImprovement(true);
    let url;
    let result;
    let AItype = "openai";
    if (AItype == "claude") {
      url = "/api/generate2";
    } else {
      url = "/api/generate";
    }

    if (improvementsNum > 1) {
      setGeneratingImprovement(false);
      setImprovements([
        ...improvements,
        "Please try making changes to your answer before asking for more improvement ideas.",
      ]);
      return;
    }

    let improvementPrompt;

    let improvementIntro = `
    You are a law professor. You asked your student this question: """ ${props.question} """.
    You expect to recieve an answer that sounds like this (correct answer): """ ${props.answer} """.
    Your student's answer is: """ ${answer} """. It is generally correct. But the student want to make it even better.
    `;

    let improvementRecommendations = `Write in second person. Address the student as "you".
       DO NOT REVEAL THE CORRECT ANSWER!!!
      Return your response with every paragrpah wrapped in <p> tags.
      Answer in ${router.locale == "ru" ? "Russian" : "English"}
      Make the answer at least 2 sentences long.`;

    if (improvementsNum == 0) {
      improvementPrompt = `
          Analyze student's answer using this information and algorithm: """${props.ifRight}""".
          Return recommendations on how to improve this answer in accordance with provided information and algorithm. 
          `;
    } else {
      improvementPrompt = `
          Use this script: ${props.ifRight} to improve the student's answer.
          Your previous recommendations are: ${improvements.join(" ")}.
        `;
    }

    try {
      const response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          prompt:
            improvementIntro + improvementPrompt + improvementRecommendations,
        }),
      });

      if (response.status !== 200) {
        throw (
          (await response.json()).error ||
          new Error(`Request failed with status ${response.status}`)
        );
      }
      const data = await response.json();
      if (AItype == "claude") {
        result = data.result.content[0].text;
      } else {
        result = data.result.content;
      }
      if (result) {
        createQuizResult({
          variables: {
            quiz: props.quizId,
            lessonId: props.lessonId,
            answer: props.answer,
            correct: false,
            type: "improvement",
            hint: AIhint,
            explanation: AIExplanation,
            improvement: result,
            comment: `Student asked for improvements`,
          },
        });
        setImprovements([...improvements, result]);
        setAIImprovement(result);
        setGeneratingImprovement(false);
        return result;
      } else {
        setAIImprovement("Sorry, we are disconnected.");
        setGeneratingImprovement(false);
        return "Sorry, we are disconnected.";
      }
    } catch (error) {
      console.error(error);
      alert(error.message);
      setGeneratingImprovement(false);
    }
  };

  // 6. Remove special characters from the sample ideal answer provided by the author

  // 7. Listening functionaluty

  const startListening = () => {
    const newRecognition = new (window.SpeechRecognition ||
      window.webkitSpeechRecognition ||
      window.mozSpeechRecognition ||
      window.msSpeechRecognition)();
    newRecognition.lang =
      guessAlphabet(props.question) == "Cyrillic" ? "ru-RU" : "en-US";
    newRecognition.interimResults = false;
    newRecognition.maxAlternatives = 1;

    newRecognition.start();
    setStartSpeech(true);

    newRecognition.onresult = function (event) {
      setAnswer(answer + " " + event.results[0][0].transcript);
    };

    newRecognition.onspeechend = function () {
      newRecognition.stop();
    };

    newRecognition.onerror = function (event) {
      console.error("Error occurred in recognition: " + event.error);
    };

    setRecognition(newRecognition);
  };

  const stopListening = () => {
    setStartSpeech(false);

    if (recognition) {
      recognition.stop();
    }
  };

  // 8. slide to the last comment generated by AI

  const slideToIdealAnswer = () => {
    var my_element = document.getElementById(`ideal_answer_${props.id}`);
    my_element.scrollIntoView({
      behavior: "smooth",
      block: "start",
      inline: "nearest",
    });
  };

  const slideToExplanations = () => {
    var my_element = document.getElementById(`last_explanation_${props.id}`);
    my_element.scrollIntoView({
      behavior: "smooth",
      block: "start",
      inline: "nearest",
    });
  };

  const slideToImprovements = () => {
    var my_element = document.getElementById(`last_improvement_${props.id}`);
    my_element.scrollIntoView({
      behavior: "smooth",
      block: "start",
      inline: "nearest",
    });
  };

  return (
    <Question story={story}>
      {/* 1 Question part */}
      <div className="question_box">
        <div className="question_text">{parse(props.question)}</div>
        <IconBlock>
          {author && author.image != null ? (
            <img className="icon" src={author.image} />
          ) : (
            <img className="icon" src="../../static/hipster.svg" />
          )}{" "}
          <div className="name">
            {author && author.name ? author.name : "BeSavvy"}
          </div>
        </IconBlock>{" "}
      </div>
      {/* 2 AI hints */}
      {hints.length > 0 &&
        hints.map((hint, index) => {
          return (
            <div className="question_box">
              <div className="question_text">
                <p>{hint}</p>
              </div>
              <IconBlock>
                {author && author.image != null ? (
                  <img className="icon" src={author.image} />
                ) : (
                  <img className="icon" src="../../static/hipster.svg" />
                )}{" "}
                <div className="name">
                  {author && author.name ? author.name : "BeSavvy"}
                </div>
              </IconBlock>
            </div>
          );
        })}
      {generating && (
        <Progress2>
          <TailSpin width="50" color="#2E80EC" />
        </Progress2>
      )}
      {/* 3. Student answer bubble part */}
      <>
        <div className="answer">
          <IconBlock>
            <div className="icon2">
              {me && me.image ? (
                <img className="icon" src={me.image} />
              ) : me.surname ? (
                `${me.name[0]}${me.surname[0]}`
              ) : (
                `${me.name[0]}${me.name[1]}`
              )}
            </div>{" "}
            <div className="name">{me.name}</div>
          </IconBlock>{" "}
          <Frame inputColor={inputColor}>
            <Answer_text
              type="text"
              required
              value={answer}
              onChange={(e) => {
                setAnswer(e.target.value);
                autoResizeTextarea(e);
              }}
              onInput={autoResizeTextarea}
              placeholder="..."
            />
            {result && (
              <ResultCircle
                data-tooltip-id="my-tooltip"
                data-tooltip-content={t("answer_above_65")}
                data-tooltip-place="right"
                inputColor={inputColor}
              >
                {parseInt(result)}
              </ResultCircle>
            )}
          </Frame>
        </div>
        {startSpeech && <Group>{<p>📣 {t("start_speaking")}..</p>}</Group>}
        <Progress display={progress}>
          <InfinitySpin width="200" color="#2E80EC" />
        </Progress>
        <Group progress={progress} correct={correct}>
          <Button1
            inputColor={inputColor}
            onClick={async (e) => {
              e.preventDefault();
              const res = await onAnswer();
              // setProgress("false");
            }}
            correct={correct}
          >
            {t("check")}
          </Button1>
          {props.goalType !== "ASSESS" && (
            <Button1
              inputColor={inputColor}
              onClick={async (e) => {
                e.preventDefault();
                let new_hint = await getHint(e);
                if (answer !== "") {
                  createQuizResult({
                    variables: {
                      quiz: props.quizId,
                      lessonId: props.lessonId,
                      answer: answer,
                      correct: false,
                      type: "hint",
                      hint: new_hint,
                      explanation: AIExplanation,
                      improvement: AIImprovement,
                      comment: `Student asked for a hint`,
                    },
                  });
                }
              }}
              correct={correct}
            >
              {AIhint && hints.length > 0
                ? t("i_need_another_hint")
                : t("i_need_a_hint")}
            </Button1>
          )}
          <Circle onClick={startListening}>
            <BiMicrophone
              className="icon"
              value={{ className: "react-icons" }}
            />
          </Circle>
          <Circle onClick={stopListening} disabled={!recognition}>
            <BiMicrophoneOff
              className="icon"
              value={{ className: "react-icons" }}
            />
          </Circle>
        </Group>
      </>
      {/* 4. Reaction to answer immediately after it is checked */}
      {/* 4.1 If true / looks true */}
      {(correct === "true" || correct === "looks_true") &&
        props.goalType !== "ASSESS" && (
          <>
            <div className="question_box">
              <div className="question_text">
                {correct === "true" && "🎉 " + t("correct") + "!"}
                {correct === "looks_true" && hint !== null && hint !== 0 && (
                  <p>{hint}</p>
                )}
                {correct === "looks_true" && "👋 " + t("looks_true")}
              </div>
              <IconBlock>
                {author && author.image != null ? (
                  <img className="icon" src={author.image} />
                ) : (
                  <img className="icon" src="../../static/hipster.svg" />
                )}{" "}
                <div className="name">
                  {author && author.name ? author.name : "BeSavvy"}
                </div>
              </IconBlock>
            </div>
          </>
        )}
      {/* 4.2 If false / has flaws */}
      {(correct === "false" || correct === "has_flaws") && (
        <>
          <div className="question_box">
            <div className="question_text">
              {correct === "false" &&
                props.goalType !== "ASSESS" &&
                "🔎  " + t("wrong") + "..."}
              {correct === "has_flaws" &&
                props.goalType !== "ASSESS" &&
                "🔎  " +
                  "You may be on right track but your answer has some flaws. Remove these flaws to find the correct answer."}

              {hint !== null && hint !== 0 && props.goalType !== "ASSESS" && (
                <p>{hint}</p>
              )}
              {props.goalType == "ASSESS" && <p>{t("saved_answer")}</p>}
            </div>
            <IconBlock>
              {author && author.image != null ? (
                <img className="icon" src={author.image} />
              ) : (
                <img className="icon" src="../../static/hipster.svg" />
              )}{" "}
              <div className="name">
                {author && author.name ? author.name : "BeSavvy"}
              </div>
            </IconBlock>
          </div>
        </>
      )}

      {/* 5. Show explanation and improvement buttons and the text */}

      {!props.challenge && correct !== "" && props.goalType !== "ASSESS" && (
        <>
          <div className="answer">
            <IconBlock>
              <div className="icon2">
                {me && me.image ? (
                  <img className="icon" src={me.image} />
                ) : me.surname ? (
                  `${me.name[0]}${me.surname[0]}`
                ) : (
                  `${me.name[0]}${me.name[1]}`
                )}
              </div>{" "}
              <div className="name">{me.name}</div>
            </IconBlock>{" "}
            {/* {correct == "false" && ( */}
            <Options>
              <Group2 progress={progress} correct={correct}>
                {(correct == "false" || correct == "has_flaws") && (
                  <Button1
                    onClick={async (e) => {
                      e.preventDefault();
                      setAIExplanation("...");
                      slideToExplanations();
                      setExplanationsNum(explanationsNum + 1);
                      const res = await getExplanation(e);
                    }}
                  >
                    {explanations.length == 0
                      ? t("explain_what_is_wrong_with_my_answer")
                      : t("more_explanations")}
                  </Button1>
                )}
                {correct == "looks_true" && (
                  <Button1
                    onClick={async (e) => {
                      e.preventDefault();
                      slideToImprovements();
                      setImprovementsNum(improvementsNum + 1);
                      const res = await getImprovements(e);
                    }}
                  >
                    {improvements.length == 0
                      ? t("what_can_i_improve")
                      : t("more_improvements")}
                  </Button1>
                )}
                <Button1
                  onClick={async (e) => {
                    e.preventDefault();
                    setHidden(false);
                    slideToIdealAnswer();
                    createQuizResult({
                      variables: {
                        quiz: props.quizId,
                        lessonId: props.lessonId,
                        answer: answer,
                        correct: false,
                        type: "answerReveal",
                        hint: AIhint,
                        explanation: AIExplanation,
                        improvement: AIImprovement,
                        comment: `Student opened correct answer`,
                      },
                    });
                  }}
                >
                  {t("show_an_ideal_answer")}
                </Button1>
              </Group2>
            </Options>
          </div>
          {explanations.length > 0 &&
            // correct !== "true" &&
            explanations.map((explanation, index) => {
              return (
                <div className="question_box">
                  <div className="question_text">{parse(explanation)}</div>
                  <IconBlock>
                    {author && author.image != null ? (
                      <img className="icon" src={author.image} />
                    ) : (
                      <img className="icon" src="../../static/hipster.svg" />
                    )}{" "}
                    <div className="name">
                      {author && author.name ? author.name : "BeSavvy"}
                    </div>
                  </IconBlock>
                </div>
              );
            })}
          <div id={`last_explanation_${props.id}`}></div>
          {generatingExplanation && (
            <Progress2>
              <TailSpin width="50" color="#2E80EC" />
            </Progress2>
          )}
          {improvements.length > 0 &&
            // (correct == "true" || correct == "looks_true") &&
            improvements.map((improvement, index) => {
              return (
                <div className="question_box">
                  <div className="question_text">{parse(improvement)}</div>
                  <IconBlock>
                    {author && author.image != null ? (
                      <img className="icon" src={author.image} />
                    ) : (
                      <img className="icon" src="../../static/hipster.svg" />
                    )}{" "}
                    <div className="name">
                      {author && author.name ? author.name : "BeSavvy"}
                    </div>
                  </IconBlock>
                </div>
              );
            })}
          <div id={`last_improvement_${props.id}`}></div>

          {generatingImprovement && (
            <Progress2>
              <TailSpin width="50" color="#2E80EC" />
            </Progress2>
          )}
        </>
      )}

      {/* 6. Show correct answer bubble */}
      <div id={`ideal_answer_${props.id}`}></div>
      {!hidden && (
        <div className="question_box">
          <div className="question_text">
            <b>{t("correct_answer")}:</b>{" "}
            {parse(removeSpecialChars(props.answer))}
            {ifRight && ifRight !== "<p></p>" && parse(ifRight)}{" "}
          </div>
          <IconBlock>
            {author && author.image != null ? (
              <img className="icon" src={author.image} />
            ) : (
              <img className="icon" src="../../static/hipster.svg" />
            )}{" "}
            <div className="name">
              {author && author.name ? author.name : "BeSavvy"}
            </div>
          </IconBlock>{" "}
        </div>
      )}
    </Question>
  );
};

OpenQuestion.propTypes = {
  author: PropTypes.object.isRequired, // Information about the author of the question
  me: PropTypes.object.isRequired, // Information about the current user
  story: PropTypes.bool.isRequired, // Determine the format of the component
  ifRight: PropTypes.string.isRequired, // Prompt to follow if the answer is correct
  ifWrong: PropTypes.string.isRequired, // Prompt to follow if the answer is incorrect
  passResult: PropTypes.func.isRequired, // Function to pass the result
  quizId: PropTypes.string.isRequired, // ID of the quiz
  lessonId: PropTypes.string.isRequired, // ID of the lesson
};

export default OpenQuestion;
