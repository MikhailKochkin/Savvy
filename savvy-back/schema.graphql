### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Application {
  applicantId: String!
  createdAt: DateTime!
  id: String!
  updatedAt: DateTime!
}

input ApplicationListRelationFilter {
  every: ApplicationWhereInput
  none: ApplicationWhereInput
  some: ApplicationWhereInput
}

input ApplicationWhereInput {
  AND: [ApplicationWhereInput!]
  applicantId: StringFilter
  applicantName: StringFilter
  coursePage: CoursePageWhereInput
  coursePageId: StringFilter
  coursePageID: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  message: StringNullableFilter
  NOT: [ApplicationWhereInput!]
  OR: [ApplicationWhereInput!]
  promocode: StringNullableFilter
  updatedAt: DateTimeFilter
}

input ApplicationWhereUniqueInput {
  id: String
}

type AuthMessage {
  message: String
}

type AuthPayload {
  token: String
  user: User
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input BoolNullableListFilter {
  equals: [Boolean!]
}

type BusinessClient {
  comment: String
  communication_history: Json
  communication_medium: String
  country: String
  coursePage: CoursePage
  coursePageId: String
  createdAt: DateTime!
  email: String!
  id: String!
  name: String
  number: String
  sales_cycle: Json
  source: String
  surname: String
  tags: [String!]!
  type: String
  updatedAt: DateTime!
}

input BusinessClientListRelationFilter {
  every: BusinessClientWhereInput
  none: BusinessClientWhereInput
  some: BusinessClientWhereInput
}

input BusinessClientOrderByInput {
  comment: SortOrder
  communication_history: SortOrder
  communication_medium: SortOrder
  country: SortOrder
  coursePageId: SortOrder
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  number: SortOrder
  sales_cycle: SortOrder
  source: SortOrder
  surname: SortOrder
  tags: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input BusinessClientWhereInput {
  AND: [BusinessClientWhereInput!]
  comment: StringNullableFilter
  communication_history: JsonNullableFilter
  communication_medium: StringNullableFilter
  country: StringNullableFilter
  coursePage: CoursePageWhereInput
  coursePageId: StringNullableFilter
  createdAt: DateTimeFilter
  email: StringFilter
  id: StringFilter
  name: StringNullableFilter
  NOT: [BusinessClientWhereInput!]
  number: StringNullableFilter
  OR: [BusinessClientWhereInput!]
  sales_cycle: JsonNullableFilter
  source: StringNullableFilter
  surname: StringNullableFilter
  tags: StringNullableListFilter
  type: StringNullableFilter
  updatedAt: DateTimeFilter
}

input BusinessClientWhereUniqueInput {
  id: String
}

input CareerTrackListRelationFilter {
  every: CareerTrackWhereInput
  none: CareerTrackWhereInput
  some: CareerTrackWhereInput
}

input CareerTrackUnitListRelationFilter {
  every: CareerTrackUnitWhereInput
  none: CareerTrackUnitWhereInput
  some: CareerTrackUnitWhereInput
}

input CareerTrackUnitWhereInput {
  AND: [CareerTrackUnitWhereInput!]
  articles: StringNullableListFilter
  careerTrack: CareerTrackWhereInput
  careerTrackId: StringFilter
  coursePages: CoursePageListRelationFilter
  createdAt: DateTimeFilter
  id: StringFilter
  img: StringNullableFilter
  NOT: [CareerTrackUnitWhereInput!]
  number: IntNullableFilter
  OR: [CareerTrackUnitWhereInput!]
  title: StringFilter
  topics: StringNullableListFilter
  updatedAt: DateTimeFilter
}

input CareerTrackWhereInput {
  AND: [CareerTrackWhereInput!]
  careerTrackUnits: CareerTrackUnitListRelationFilter
  coursePages: CoursePageListRelationFilter
  createdAt: DateTimeFilter
  id: StringFilter
  img: StringNullableFilter
  members: UserWhereInput
  name: StringFilter
  NOT: [CareerTrackWhereInput!]
  OR: [CareerTrackWhereInput!]
  updatedAt: DateTimeFilter
}

type Certificate {
  coursePage: CoursePage!
  coursePageId: String!
  createdAt: DateTime!
  id: String!
  student: User!
  studentId: String!
  updatedAt: DateTime!
}

input CertificateListRelationFilter {
  every: CertificateWhereInput
  none: CertificateWhereInput
  some: CertificateWhereInput
}

input CertificateOrderByInput {
  coursePageId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  studentId: SortOrder
  updatedAt: SortOrder
}

input CertificateWhereInput {
  AND: [CertificateWhereInput!]
  coursePage: CoursePageWhereInput
  coursePageId: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [CertificateWhereInput!]
  OR: [CertificateWhereInput!]
  student: UserWhereInput
  studentId: StringFilter
  updatedAt: DateTimeFilter
}

input CertificateWhereUniqueInput {
  id: String
}

type ChallengeResult {
  correct: Int
  createdAt: DateTime!
  id: String!
  lesson: Lesson!
  lessonId: String!
  student: User!
  studentId: String!
  time: Int
  updatedAt: DateTime!
  wrong: Int
}

input ChallengeResultListRelationFilter {
  every: ChallengeResultWhereInput
  none: ChallengeResultWhereInput
  some: ChallengeResultWhereInput
}

input ChallengeResultOrderByInput {
  correct: SortOrder
  createdAt: SortOrder
  id: SortOrder
  lessonId: SortOrder
  studentId: SortOrder
  time: SortOrder
  updatedAt: SortOrder
  wrong: SortOrder
}

input ChallengeResultWhereInput {
  AND: [ChallengeResultWhereInput!]
  correct: IntNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  NOT: [ChallengeResultWhereInput!]
  OR: [ChallengeResultWhereInput!]
  student: UserWhereInput
  studentId: StringFilter
  time: IntNullableFilter
  updatedAt: DateTimeFilter
  wrong: IntNullableFilter
}

input ChallengeResultWhereUniqueInput {
  id: String
}

type Chat {
  complexity: Int
  createdAt: DateTime!
  id: String!
  isSecret: Boolean
  lesson: Lesson!
  lessonId: String!
  link_clicks: Int
  messages: Json
  name: String
  updatedAt: DateTime!
  user: User!
}

input ChatListRelationFilter {
  every: ChatWhereInput
  none: ChatWhereInput
  some: ChatWhereInput
}

input ChatOrderByInput {
  complexity: SortOrder
  createdAt: SortOrder
  id: SortOrder
  isSecret: SortOrder
  lessonId: SortOrder
  link_clicks: SortOrder
  messages: SortOrder
  name: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input ChatWhereInput {
  AND: [ChatWhereInput!]
  complexity: IntNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  isSecret: BoolNullableFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  link_clicks: IntNullableFilter
  messages: JsonNullableFilter
  name: StringNullableFilter
  NOT: [ChatWhereInput!]
  OR: [ChatWhereInput!]
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input ChatWhereUniqueInput {
  id: String
}

type Clause {
  commentary: String!
  createdAt: DateTime!
  document: Document!
  documentId: String!
  id: String!
  keywords: [String!]!
  number: Int!
  sample: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input ClauseListRelationFilter {
  every: ClauseWhereInput
  none: ClauseWhereInput
  some: ClauseWhereInput
}

input ClauseWhereInput {
  AND: [ClauseWhereInput!]
  commentary: StringFilter
  createdAt: DateTimeFilter
  document: DocumentWhereInput
  documentId: StringFilter
  id: StringFilter
  keywords: StringNullableListFilter
  NOT: [ClauseWhereInput!]
  number: IntFilter
  OR: [ClauseWhereInput!]
  sample: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input ClauseWhereUniqueInput {
  id: String
}

input ClientMessage {
  date: String
  message: String
}

input ClientMessages {
  messages: [ClientMessage]
}

type CommunityMember {
  createdAt: DateTime!
  email: String!
  id: String!
  name: String!
  number: String
  source: String
  subscription: String
  surname: String
  updatedAt: DateTime!
}

type Company {
  id: String!
  name: String!
}

input CompanyWhereInput {
  AND: [CompanyWhereInput!]
  coursePage: CoursePageListRelationFilter
  createdAt: DateTimeFilter
  hrs: UserListRelationFilter
  id: StringFilter
  name: StringFilter
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  paidMonths: IntNullableFilter
  updatedAt: DateTimeFilter
}

type ConfUser {
  conf_number: Int
  createdAt: DateTime!
  email: String!
  id: String!
  name: String
  surname: String
  updatedAt: DateTime!
}

type Construction {
  answer: [String!]!
  columnsNum: Int
  complexity: Int
  constructionResults(after: ConstructionResultWhereUniqueInput, before: ConstructionResultWhereUniqueInput, first: Int, last: Int): [ConstructionResult!]!
  createdAt: DateTime!
  elements: Json
  hasText: Boolean!
  hint: String
  id: String!
  lesson: Lesson!
  lessonId: String!
  lessonID: String!
  name: String!
  text: String
  type: String!
  updatedAt: DateTime!
  user: User!
  userId: String!
  variants: [String!]!
}

input ConstructionListRelationFilter {
  every: ConstructionWhereInput
  none: ConstructionWhereInput
  some: ConstructionWhereInput
}

type ConstructionResult {
  answer: String
  attempts: Int
  construction: Construction
  constructionId: String
  constructionID: String
  createdAt: DateTime!
  id: String!
  inputs: [String!]!
  lesson: Lesson
  lessonId: String
  lessonID: String
  student: User!
  studentId: String!
  updatedAt: DateTime!
}

input ConstructionResultListRelationFilter {
  every: ConstructionResultWhereInput
  none: ConstructionResultWhereInput
  some: ConstructionResultWhereInput
}

input ConstructionResultWhereInput {
  AND: [ConstructionResultWhereInput!]
  answer: StringNullableFilter
  attempts: IntNullableFilter
  construction: ConstructionWhereInput
  constructionId: StringNullableFilter
  constructionID: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  inputs: StringNullableListFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  NOT: [ConstructionResultWhereInput!]
  OR: [ConstructionResultWhereInput!]
  student: UserWhereInput
  studentId: StringFilter
  updatedAt: DateTimeFilter
}

input ConstructionResultWhereUniqueInput {
  id: String
}

input ConstructionWhereInput {
  AND: [ConstructionWhereInput!]
  answer: StringNullableListFilter
  columnsNum: IntNullableFilter
  complexity: IntNullableFilter
  constructionResults: ConstructionResultListRelationFilter
  createdAt: DateTimeFilter
  elements: JsonNullableFilter
  hasText: BoolFilter
  hint: StringNullableFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  lessonID: StringFilter
  name: StringFilter
  NOT: [ConstructionWhereInput!]
  OR: [ConstructionWhereInput!]
  text: StringNullableFilter
  type: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
  variants: StringNullableListFilter
}

input ConstructionWhereUniqueInput {
  id: String
}

type CoursePage {
  applications(after: ApplicationWhereUniqueInput, before: ApplicationWhereUniqueInput, first: Int, last: Int): [Application!]!
  audience: String
  authors(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
  banner: String
  batch: String
  company: Company
  countries: [String!]!
  courseType: CourseType
  createdAt: DateTime!
  currency: String
  description: String!
  discountPrice: Int
  goals: [String!]!
  header: [String!]!
  id: String!
  image: String!
  installments: Int
  lessons(after: LessonWhereUniqueInput, before: LessonWhereUniqueInput, first: Int, last: Int): [Lesson!]!
  methods: String
  new_students(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, where: UserWhereInput): [User!]!
  news: String
  nextStart: DateTime
  numInCareerTrack: Int
  orders(after: OrderWhereUniqueInput, before: OrderWhereUniqueInput, first: Int, last: Int): [Order!]!
  price: Int
  prices: Json
  promocode: Json
  published: Boolean
  result: String
  reviews: Json
  students: [String!]!
  subheader: [String!]!
  subscription: Boolean
  subscriptionPrice: Int
  tags: [String!]!
  tariffs: String
  title: String!
  uni: Uni
  updatedAt: DateTime!
  uptodateAt: DateTime
  user: User!
  video: String
  view: PageView!
  weeks: Int
}

input CoursePageListRelationFilter {
  every: CoursePageWhereInput
  none: CoursePageWhereInput
  some: CoursePageWhereInput
}

input CoursePageOrderByInput {
  audience: SortOrder
  banner: SortOrder
  batch: SortOrder
  companyId: SortOrder
  countries: SortOrder
  courseType: SortOrder
  createdAt: SortOrder
  currency: SortOrder
  description: SortOrder
  discountPrice: SortOrder
  examQuestionId: SortOrder
  goals: SortOrder
  header: SortOrder
  id: SortOrder
  image: SortOrder
  installments: SortOrder
  methods: SortOrder
  news: SortOrder
  nextStart: SortOrder
  numInCareerTrack: SortOrder
  openLesson: SortOrder
  price: SortOrder
  prices: SortOrder
  promocode: SortOrder
  published: SortOrder
  result: SortOrder
  reviews: SortOrder
  students: SortOrder
  subheader: SortOrder
  subscription: SortOrder
  subscriptionPrice: SortOrder
  tags: SortOrder
  tariffs: SortOrder
  title: SortOrder
  uniId: SortOrder
  uniID: SortOrder
  updatedAt: SortOrder
  uptodateAt: SortOrder
  userId: SortOrder
  video: SortOrder
  view: SortOrder
  weeks: SortOrder
}

input CoursePageWhereInput {
  AND: [CoursePageWhereInput!]
  applications: ApplicationListRelationFilter
  audience: StringNullableFilter
  authors: UserListRelationFilter
  banner: StringNullableFilter
  batch: StringNullableFilter
  businessClients: BusinessClientListRelationFilter
  careerTrack: CareerTrackListRelationFilter
  careerTrackUnit: CareerTrackUnitListRelationFilter
  certificates: CertificateListRelationFilter
  company: CompanyWhereInput
  companyId: StringNullableFilter
  countries: StringNullableListFilter
  courseType: EnumCourseTypeNullableFilter
  createdAt: DateTimeFilter
  currency: StringNullableFilter
  description: StringFilter
  discountPrice: IntNullableFilter
  examQuestion: ExamQuestionWhereInput
  examQuestionId: StringNullableFilter
  goals: StringNullableListFilter
  header: StringNullableListFilter
  id: StringFilter
  image: StringFilter
  installments: IntNullableFilter
  lawrdles: LawrdleListRelationFilter
  lessons: LessonListRelationFilter
  methods: StringNullableFilter
  new_students: UserListRelationFilter
  news: StringNullableFilter
  nextStart: DateTimeNullableFilter
  NOT: [CoursePageWhereInput!]
  numInCareerTrack: IntNullableFilter
  openLesson: StringNullableFilter
  OR: [CoursePageWhereInput!]
  orders: OrderListRelationFilter
  PointA: PointAListRelationFilter
  PointATest: PointATestListRelationFilter
  posts: PostListRelationFilter
  price: IntNullableFilter
  prices: JsonNullableFilter
  programs: ProgramListRelationFilter
  promocode: JsonNullableFilter
  published: BoolNullableFilter
  result: StringNullableFilter
  reviews: JsonNullableFilter
  students: StringNullableListFilter
  subheader: StringNullableListFilter
  subscription: BoolNullableFilter
  subscriptionPrice: IntNullableFilter
  tags: StringNullableListFilter
  tariffs: StringNullableFilter
  title: StringFilter
  uni: UniWhereInput
  uniId: StringNullableFilter
  uniID: StringNullableFilter
  updatedAt: DateTimeFilter
  uptodateAt: DateTimeNullableFilter
  user: UserWhereInput
  userId: StringFilter
  video: StringNullableFilter
  view: EnumPageViewFilter
  visits: CourseVisitListRelationFilter
  weeks: IntNullableFilter
}

input CoursePageWhereUniqueInput {
  examQuestionId: String
  id: String
}

"""The first Star Wars episodes released"""
enum CourseType {
  CHALLENGE
  FORMONEY
  PRIVATE
  PUBLIC
  UNI
}

type CourseVisit {
  coursePage: CoursePage!
  coursePageId: String!
  createdAt: DateTime!
  id: String!
  reminders: [DateTime!]!
  student: User!
  studentId: String!
  updatedAt: DateTime!
  visitsNumber: Int
}

input CourseVisitListRelationFilter {
  every: CourseVisitWhereInput
  none: CourseVisitWhereInput
  some: CourseVisitWhereInput
}

input CourseVisitOrderByInput {
  comment: SortOrder
  coursePageId: SortOrder
  createdAt: SortOrder
  finish: SortOrder
  id: SortOrder
  info: SortOrder
  reminders: SortOrder
  studentId: SortOrder
  updatedAt: SortOrder
  visitsNumber: SortOrder
}

input CourseVisitWhereInput {
  AND: [CourseVisitWhereInput!]
  comment: StringNullableFilter
  coursePage: CoursePageWhereInput
  coursePageId: StringFilter
  createdAt: DateTimeFilter
  finish: DateTimeNullableFilter
  id: StringFilter
  info: JsonNullableFilter
  NOT: [CourseVisitWhereInput!]
  OR: [CourseVisitWhereInput!]
  reminders: DateTimeNullableListFilter
  student: UserWhereInput
  studentId: StringFilter
  updatedAt: DateTimeFilter
  visitsNumber: IntNullableFilter
}

input CourseVisitWhereUniqueInput {
  id: String
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableListFilter {
  equals: [DateTime!]
}

type Document {
  clauses(after: ClauseWhereUniqueInput, before: ClauseWhereUniqueInput, first: Int, last: Int): [Clause!]!
  complexity: Int
  createdAt: DateTime!
  documentResults(after: DocumentResultWhereUniqueInput, before: DocumentResultWhereUniqueInput, first: Int, last: Int): [DocumentResult!]!
  id: String!
  lesson: Lesson!
  lessonId: String!
  title: String!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input DocumentListRelationFilter {
  every: DocumentWhereInput
  none: DocumentWhereInput
  some: DocumentWhereInput
}

type DocumentResult {
  answers: [String!]!
  createdAt: DateTime!
  document: Document
  documentId: String
  drafts: [String!]!
  id: String!
  lesson: Lesson
  lessonId: String
  updatedAt: DateTime!
  user: User
  userId: String
}

input DocumentResultListRelationFilter {
  every: DocumentResultWhereInput
  none: DocumentResultWhereInput
  some: DocumentResultWhereInput
}

input DocumentResultWhereInput {
  AND: [DocumentResultWhereInput!]
  answers: StringNullableListFilter
  createdAt: DateTimeFilter
  document: DocumentWhereInput
  documentId: StringNullableFilter
  drafts: StringNullableListFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  NOT: [DocumentResultWhereInput!]
  OR: [DocumentResultWhereInput!]
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringNullableFilter
}

input DocumentResultWhereUniqueInput {
  id: String
}

input DocumentWhereInput {
  AND: [DocumentWhereInput!]
  clauses: ClauseListRelationFilter
  complexity: IntNullableFilter
  createdAt: DateTimeFilter
  documentResults: DocumentResultListRelationFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  NOT: [DocumentWhereInput!]
  OR: [DocumentWhereInput!]
  title: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input DocumentWhereUniqueInput {
  id: String
}

input Element {
  inDoc: Boolean
  isTest: Boolean
  place: Int
  size: Int
  text: String
  type: String
  value: String
}

input ElementsList {
  elements: [Element]
}

input EmailInfo {
  completed_lessons_number: Int
  course_name: String
  lesResultsList: LesResultsList
  lessons_number: Int
  student_name: String
}

input EnumCourseTypeNullableFilter {
  equals: CourseType
  in: [CourseType!]
  not: NestedEnumCourseTypeNullableFilter
  notIn: [CourseType!]
}

input EnumLevelNullableFilter {
  equals: Level
  in: [Level!]
  not: NestedEnumLevelNullableFilter
  notIn: [Level!]
}

input EnumPageViewFilter {
  equals: PageView
  in: [PageView!]
  not: NestedEnumPageViewFilter
  notIn: [PageView!]
}

input EnumPermissionNullableListFilter {
  equals: [Permission!]
}

input ExamAnswerListRelationFilter {
  every: ExamAnswerWhereInput
  none: ExamAnswerWhereInput
  some: ExamAnswerWhereInput
}

input ExamAnswerWhereInput {
  AND: [ExamAnswerWhereInput!]
  answer: StringFilter
  createdAt: DateTimeFilter
  examQuestion: ExamQuestionWhereInput
  examQuestionId: StringFilter
  examQuestionID: StringFilter
  id: StringFilter
  legalPortfolio: LegalPortfolioListRelationFilter
  NOT: [ExamAnswerWhereInput!]
  OR: [ExamAnswerWhereInput!]
  studentId: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
}

input ExamListRelationFilter {
  every: ExamWhereInput
  none: ExamWhereInput
  some: ExamWhereInput
}

input ExamQuestionWhereInput {
  AND: [ExamQuestionWhereInput!]
  coursePage: CoursePageWhereInput
  coursePageID: StringFilter
  createdAt: DateTimeFilter
  examAnswer: ExamAnswerListRelationFilter
  id: StringFilter
  NOT: [ExamQuestionWhereInput!]
  OR: [ExamQuestionWhereInput!]
  question: StringFilter
  updatedAt: DateTimeFilter
}

input ExamResultListRelationFilter {
  every: ExamResultWhereInput
  none: ExamResultWhereInput
  some: ExamResultWhereInput
}

input ExamResultWhereInput {
  AND: [ExamResultWhereInput!]
  answers: StringNullableListFilter
  createdAt: DateTimeFilter
  exam: ExamWhereInput
  examId: StringNullableFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  NOT: [ExamResultWhereInput!]
  OR: [ExamResultWhereInput!]
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringNullableFilter
}

input ExamWhereInput {
  AND: [ExamWhereInput!]
  createdAt: DateTimeFilter
  examResult: ExamResultListRelationFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  name: StringNullableFilter
  nodeID: StringNullableFilter
  nodeType: StringNullableFilter
  NOT: [ExamWhereInput!]
  OR: [ExamWhereInput!]
  question: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

type Feedback {
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  lessonId: String
  student: User!
  studentId: String!
  teacher: User!
  teacherId: String!
  text: String!
  updatedAt: DateTime!
}

input FeedbackListRelationFilter {
  every: FeedbackWhereInput
  none: FeedbackWhereInput
  some: FeedbackWhereInput
}

input FeedbackOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  lessonId: SortOrder
  studentId: SortOrder
  teacherId: SortOrder
  text: SortOrder
  updatedAt: SortOrder
}

input FeedbackWhereInput {
  AND: [FeedbackWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  NOT: [FeedbackWhereInput!]
  OR: [FeedbackWhereInput!]
  student: UserWhereInput
  studentId: StringFilter
  teacher: UserWhereInput
  teacherId: StringFilter
  text: StringFilter
  updatedAt: DateTimeFilter
}

input FeedbackWhereUniqueInput {
  id: String
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

type Forum {
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  rating(after: RatingWhereUniqueInput, before: RatingWhereUniqueInput, first: Int, last: Int): [Rating!]!
  statements(after: StatementWhereUniqueInput, before: StatementWhereUniqueInput, first: Int, last: Int): [Statement!]!
  text: String
  updatedAt: DateTime!
  user: User
  userId: String
}

input ForumListRelationFilter {
  every: ForumWhereInput
  none: ForumWhereInput
  some: ForumWhereInput
}

input ForumWhereInput {
  AND: [ForumWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  NOT: [ForumWhereInput!]
  OR: [ForumWhereInput!]
  rating: RatingListRelationFilter
  statements: StatementListRelationFilter
  text: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringNullableFilter
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

input JsonNullableFilter {
  equals: Json
  not: Json
}

input JsonNullableListFilter {
  equals: [Json!]
}

type Lawrdle {
  active: Boolean!
  author: User!
  authorId: String!
  buttonText: String
  createdAt: DateTime!
  id: String!
  link: String
  story: String!
  updatedAt: DateTime!
  word: String!
}

input LawrdleListRelationFilter {
  every: LawrdleWhereInput
  none: LawrdleWhereInput
  some: LawrdleWhereInput
}

input LawrdleOrderByInput {
  active: SortOrder
  authorId: SortOrder
  buttonText: SortOrder
  coursePageId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  link: SortOrder
  pros: SortOrder
  story: SortOrder
  tags: SortOrder
  updatedAt: SortOrder
  word: SortOrder
}

input LawrdleWhereInput {
  active: BoolFilter
  AND: [LawrdleWhereInput!]
  author: UserWhereInput
  authorId: StringFilter
  buttonText: StringNullableFilter
  coursePage: CoursePageWhereInput
  coursePageId: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  link: StringNullableFilter
  NOT: [LawrdleWhereInput!]
  OR: [LawrdleWhereInput!]
  pros: StringNullableListFilter
  story: StringFilter
  tags: StringNullableListFilter
  updatedAt: DateTimeFilter
  word: StringFilter
}

input LawrdleWhereUniqueInput {
  id: String
}

input LegalPortfolioListRelationFilter {
  every: LegalPortfolioWhereInput
  none: LegalPortfolioWhereInput
  some: LegalPortfolioWhereInput
}

input LegalPortfolioWhereInput {
  AND: [LegalPortfolioWhereInput!]
  createdAt: DateTimeFilter
  cv: StringNullableFilter
  examAnswer: ExamAnswerListRelationFilter
  id: StringFilter
  NOT: [LegalPortfolioWhereInput!]
  open: BoolFilter
  OR: [LegalPortfolioWhereInput!]
  portfolioIDs: StringNullableListFilter
  resume: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
}

input LesResult {
  lesson_name: String
  lesson_number: Int
  lesson_size: Int
  progress: Int
  visits: Int
}

input LesResultsList {
  lesResults: [LesResult]
}

type Lesson {
  assignment: Boolean
  challenge_num: Int
  challengeResults(after: ChallengeResultWhereUniqueInput, before: ChallengeResultWhereUniqueInput, first: Int, last: Int): [ChallengeResult!]!
  change: String
  chats(after: ChatWhereUniqueInput, before: ChatWhereUniqueInput, first: Int, last: Int): [Chat!]!
  constructionResults(after: ConstructionResultWhereUniqueInput, before: ConstructionResultWhereUniqueInput, first: Int, last: Int): [ConstructionResult!]!
  constructions(after: ConstructionWhereUniqueInput, before: ConstructionWhereUniqueInput, first: Int, last: Int): [Construction!]!
  coursePage: CoursePage!
  coursePageId: String!
  coursePageID: String!
  createdAt: DateTime!
  description: String
  documents(after: DocumentWhereUniqueInput, before: DocumentWhereUniqueInput, first: Int, last: Int): [Document!]!
  forum: Forum
  forumId: String
  hasSecret: Boolean
  id: String!
  lessonResults(after: LessonResultWhereUniqueInput, before: LessonResultWhereUniqueInput, first: Int, last: Int): [LessonResult!]!
  map: [Json!]!
  miniforums(after: MiniForumWhereUniqueInput, before: MiniForumWhereUniqueInput, first: Int, last: Int): [MiniForum!]!
  name: String!
  newTests(after: NewTestWhereUniqueInput, before: NewTestWhereUniqueInput, first: Int, last: Int): [NewTest!]!
  notes(after: NoteWhereUniqueInput, before: NoteWhereUniqueInput, first: Int, last: Int): [Note!]!
  number: Int
  offers(after: OfferWhereUniqueInput, before: OfferWhereUniqueInput, first: Int, last: Int): [Offer!]!
  open: Boolean
  problemResults(after: ProblemResultWhereUniqueInput, before: ProblemResultWhereUniqueInput, first: Int, last: Int): [ProblemResult!]!
  problems(after: ProblemWhereUniqueInput, before: ProblemWhereUniqueInput, first: Int, last: Int): [Problem!]!
  published: Boolean
  quizes(after: QuizWhereUniqueInput, before: QuizWhereUniqueInput, first: Int, last: Int): [Quiz!]!
  quizResults(after: QuizResultWhereUniqueInput, before: QuizResultWhereUniqueInput, first: Int, last: Int): [QuizResult!]!
  short_structure: Json
  shotResults(after: ShotResultWhereUniqueInput, before: ShotResultWhereUniqueInput, first: Int, last: Int): [ShotResult!]!
  shots(after: ShotWhereUniqueInput, before: ShotWhereUniqueInput, first: Int, last: Int): [Shot!]!
  structure: Json
  teamQuestResults(after: TeamQuestResultWhereUniqueInput, before: TeamQuestResultWhereUniqueInput, first: Int, last: Int): [TeamQuestResult!]!
  teamQuests(after: TeamQuestWhereUniqueInput, before: TeamQuestWhereUniqueInput, first: Int, last: Int): [TeamQuest!]!
  testPractices(after: TestPracticeWhereUniqueInput, before: TestPracticeWhereUniqueInput, first: Int, last: Int): [TestPractice!]!
  testResults(after: TestResultWhereUniqueInput, before: TestResultWhereUniqueInput, first: Int, last: Int): [TestResult!]!
  text: String!
  textEditorResults(after: TextEditorResultWhereUniqueInput, before: TextEditorResultWhereUniqueInput, first: Int, last: Int): [TextEditorResult!]!
  texteditors(after: TextEditorWhereUniqueInput, before: TextEditorWhereUniqueInput, first: Int, last: Int): [TextEditor!]!
  totalPoints: Int
  type: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input LessonItem {
  id: String
  type: String
}

input LessonListRelationFilter {
  every: LessonWhereInput
  none: LessonWhereInput
  some: LessonWhereInput
}

type LessonResult {
  checked: Boolean
  createdAt: DateTime!
  id: String!
  lesson: Lesson!
  lessonID: String
  progress: Int
  student: User!
  updatedAt: DateTime!
  visitsNumber: Int
}

input LessonResultListRelationFilter {
  every: LessonResultWhereInput
  none: LessonResultWhereInput
  some: LessonResultWhereInput
}

input LessonResultOrderByInput {
  checked: SortOrder
  createdAt: SortOrder
  id: SortOrder
  lessonId: SortOrder
  lessonID: SortOrder
  progress: SortOrder
  studentId: SortOrder
  updatedAt: SortOrder
  visitsNumber: SortOrder
}

input LessonResultWhereInput {
  AND: [LessonResultWhereInput!]
  checked: BoolNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  lessonID: StringNullableFilter
  NOT: [LessonResultWhereInput!]
  OR: [LessonResultWhereInput!]
  progress: IntNullableFilter
  student: UserWhereInput
  studentId: StringFilter
  updatedAt: DateTimeFilter
  visitsNumber: IntNullableFilter
}

input LessonResultWhereUniqueInput {
  id: String
}

input LessonStructure {
  lessonItems: [LessonItem]
}

input LessonWhereInput {
  AND: [LessonWhereInput!]
  assignment: BoolNullableFilter
  challenge_num: IntNullableFilter
  challengeResults: ChallengeResultListRelationFilter
  change: StringNullableFilter
  chats: ChatListRelationFilter
  constructionResults: ConstructionResultListRelationFilter
  constructions: ConstructionListRelationFilter
  coursePage: CoursePageWhereInput
  coursePageId: StringFilter
  coursePageID: StringFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  documentResult: DocumentResultListRelationFilter
  documents: DocumentListRelationFilter
  exam: ExamListRelationFilter
  examResult: ExamResultListRelationFilter
  forum: ForumWhereInput
  forumId: StringNullableFilter
  hasSecret: BoolNullableFilter
  id: StringFilter
  image: StringNullableFilter
  lessonFeedback: FeedbackListRelationFilter
  lessonResults: LessonResultListRelationFilter
  map: JsonNullableListFilter
  miniforums: MiniForumListRelationFilter
  name: StringFilter
  newTests: NewTestListRelationFilter
  NOT: [LessonWhereInput!]
  notes: NoteListRelationFilter
  number: IntNullableFilter
  offers: OfferListRelationFilter
  open: BoolNullableFilter
  OR: [LessonWhereInput!]
  problemResults: ProblemResultListRelationFilter
  problems: ProblemListRelationFilter
  published: BoolNullableFilter
  quizes: QuizListRelationFilter
  quizResults: QuizResultListRelationFilter
  short_structure: JsonNullableFilter
  shotResults: ShotResultListRelationFilter
  shots: ShotListRelationFilter
  structure: JsonNullableFilter
  teamQuestResults: TeamQuestResultListRelationFilter
  teamQuests: TeamQuestListRelationFilter
  test: TestListRelationFilter
  testPracticeResults: TestPracticeResultListRelationFilter
  testPractices: TestPracticeListRelationFilter
  testResults: TestResultListRelationFilter
  text: StringFilter
  textEditorResults: TextEditorResultListRelationFilter
  texteditors: TextEditorListRelationFilter
  totalPoints: IntNullableFilter
  type: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input LessonWhereUniqueInput {
  forumId: String
  id: String
}

enum Level {
  ADVANCED
  STANDARD
}

type Message {
  createdAt: DateTime!
  id: String!
  text: String
  updatedAt: DateTime!
  user: User
  userId: String
}

input MessageElement {
  author: String
  image: String
  name: String
  number: Int
  reactions: [Reaction]
  text: String
}

input MessageListRelationFilter {
  every: MessageWhereInput
  none: MessageWhereInput
  some: MessageWhereInput
}

input Messages {
  messagesList: [MessageElement]
}

input MessageWhereInput {
  AND: [MessageWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [MessageWhereInput!]
  OR: [MessageWhereInput!]
  text: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringNullableFilter
}

input MessageWhereUniqueInput {
  id: String
}

type MiniForum {
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  lessonId: String
  statements(after: StatementWhereUniqueInput, before: StatementWhereUniqueInput, first: Int, last: Int): [Statement!]!
  type: String
  updatedAt: DateTime!
  user: User
  userId: String
  value: String
}

input MiniForumListRelationFilter {
  every: MiniForumWhereInput
  none: MiniForumWhereInput
  some: MiniForumWhereInput
}

input MiniForumWhereInput {
  AND: [MiniForumWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  NOT: [MiniForumWhereInput!]
  OR: [MiniForumWhereInput!]
  statements: StatementListRelationFilter
  text: StringNullableFilter
  type: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringNullableFilter
  value: StringNullableFilter
}

input MiniForumWhereUniqueInput {
  id: String
}

type Mutation {
  addToTeam(id: String): User
  advancedSignup(careerTrackID: String, company: String, country: String, email: String, isFamiliar: Boolean, name: String, number: String, password: String, status: Status, surname: String, traffic_sources: Visits, uniID: String): AuthPayload
  checkAssignment(checked: Boolean, id: String): LessonResult
  createBusinessClient(comment: String, country: String, coursePageId: String, email: String, name: String, number: String, sales_cycle: SalesCycle, source: String, surname: String, type: String): User
  createCertificate(coursePageId: String, studentId: String): Certificate
  createChallengeResult(correct: Int, lesson: String, time: Int, wrong: Int): ChallengeResult
  createChat(lessonId: String, messages: Messages, name: String): Chat
  createClause(commentary: String, documentId: String, keywords: [String], number: Int, sample: String, title: String): Clause
  createCommunityMember(email: String, name: String, number: String, subscription: String, surname: String): PaymentInfo2
  createConfUser(conf_number: Int, email: String): ConfUser
  createConstruction(answer: [String], columnsNum: Int, elements: ElementsList, hasText: Boolean, hint: String, lessonId: String, name: String, text: String, type: String, variants: [String]): Construction
  createConstructionResult(answer: String, attempts: Int, constructionId: String, inputs: [String], lessonId: String): ConstructionResult
  createCoursePage(audience: String, courseType: String, description: String, image: String, published: Boolean, result: String, title: String): CoursePage
  createCourseVisit(coursePageId: String, studentId: String, visitsNumber: Int): CourseVisit
  createDocument(lessonId: String, title: String): Document
  createDocumentResult(answers: [String], documentId: String, drafts: [String], lessonId: String): DocumentResult
  createFeedback(lessonId: String, studentId: String, text: String): Feedback
  createForum(lessonId: String, text: String): Forum
  createLawrdle(active: Boolean, authorId: String, buttonText: String, coursePageId: String, link: String, story: String, tags: [String], word: String): Lawrdle
  createLesson(coursePageID: String, description: String, name: String, number: Int, text: String): Lesson
  createLessonResult(lessonID: String, visitsNumber: Int): LessonResult
  createMiniForum(lessonId: String, type: String, value: String): MiniForum
  createMiniStatement(miniforumId: String, text: String): Statement
  createNewTest(answers: [String], comments: [String], correct: [Boolean], ifRight: String, ifWrong: String, lessonId: String, question: [String], type: String): NewTest
  createNote(lessonId: String, text: String): Note
  createOffer(courseId: String, discountPrice: Int, header: String, lessonId: String, price: Int, text: String, type: String): Offer
  createOrder(comment: String, coursePageId: String, price: Int, promocode: String, userId: String): PaymentInfo
  createPost(image: String, summary: String, text: String, title: String): Post
  createPrivateOrder(coursePageId: String, promocode: String, userId: String): PaymentInfo
  createProblem(lessonId: String, steps: ProblemStructure, text: String): Problem
  createProblemResult(answer: String, lessonId: String, problemID: String, revealed: [String]): ProblemResult
  createProgram(audience: String, description: String, goals: [String], header: [String], image: String, methods: String, nextStart: DateTime, price: Int, result: String, subheader: [String], title: String): Program
  createQuiz(answer: String, ifRight: String, ifWrong: String, lessonId: String, question: String, type: String): Quiz
  createQuizResult(answer: String, correct: Boolean, lessonId: String, quiz: String): QuizResult
  createRating(forumId: String, rating: Int): Rating
  createShot(comments: [String], lessonId: String, parts: [String], title: String): Shot
  createShotResult(answer: String, lessonId: String, shotId: String): ShotResult
  createStatement(forumId: String, miniforumId: String, text: String): Statement
  createTeam(name: String): Team
  createTeamQuest(introduction: String, lessonId: String, solution: String, tasks: QuestList): TeamQuest
  createTeamQuestResult(answer: String, lessonId: String, teamQuestId: String): TeamQuestResult
  createTestPractice(failureText: String, intro: String, lessonId: String, successText: String, tasks: [String], tasksNum: Int, text: String): TestPractice
  createTestPracticeResult(correct: Int, lessonId: String, tasks: [String], testPracticeId: String): TestPracticeResult
  createTestResult(answer: String, lessonID: String, testID: String): TestResult
  createTextEditor(lessonId: String, name: String, text: String, totalMistakes: Int): TextEditor
  createTextEditorResult(attempts: Int, correct: String, guess: String, lessonId: String, result: Boolean, textEditorId: String, type: String, wrong: String): TextEditorResult
  createUseful(buttonText: String, header: String, image: String, link: String, tags: [String]): Useful
  deleteChat(id: String): Chat
  deleteClause(id: String): Clause
  deleteClient(id: String): BusinessClient
  deleteConstruction(id: String): Construction
  deleteDocument(id: String): Document
  deleteLesson(id: String): Lesson
  deleteNewTest(id: String): NewTest
  deleteNote(id: String): Note
  deleteOrder(id: String): Order
  deletePost(id: String): Post
  deleteProblem(id: String): Problem
  deleteQuiz(id: String): Quiz
  deleteShot(id: String): Shot
  deleteStatement(id: String): Statement
  deleteTextEditor(id: String): TextEditor
  enrollOnCourse(coursePageId: String, id: String): User
  publishCourse(id: String, published: Boolean): CoursePage
  recordSession(id: String, traffic_sources: Visits): User
  remind(id: String, reminders: [DateTime]): CourseVisit
  requestReset(email: String): AuthMessage
  resetPassword(confirmPassword: String, password: String, resetToken: String): User
  sendBusinessClientEmail(communication_history: ClientMessages, id: String): BusinessClient
  sendEmailToStudent(comment: String, id: String, info: EmailInfo, reminders: [DateTime]): CourseVisit
  sendMessage(text: String, userId: String): Message
  signin(email: String, password: String, traffic_sources: Visits): AuthPayload
  signout: SignOut
  signup(careerTrackID: String, company: String, country: String, email: String, isFamiliar: Boolean, name: String, number: String, password: String, status: Status, surname: String, traffic_sources: Visits, uniID: String): AuthPayload
  textBusinessClient(comment: String, id: String): BusinessClient
  updateBusinessClient(comment: String, communication_history: ClientMessages, id: String, number: String, sales_cycle: SalesCycle, tags: [String]): BusinessClient
  updateChat(id: String, isSecret: Boolean, link_clicks: Int, messages: Messages, name: String): Chat
  updateClause(commentary: String, id: String, keywords: [String], number: Int, sample: String, text: String): Clause
  updateConfUser(id: String, name: String, surname: String): ConfUser
  updateConstruction(answer: [String], columnsNum: Int, complexity: Int, elements: ElementsList, hint: String, id: String, name: String, type: String, variants: [String]): Construction
  updateCoursePage(audience: String, authors: String, currency: String, description: String, discountPrice: Int, goals: [String], header: [String], id: String, image: String, methods: String, news: String, nextStart: DateTime, price: Int, prices: Prices, promocode: PromocodeList, result: String, subheader: [String], tariffs: String, title: String, uptodateAt: DateTime, video: String): CoursePage
  updateCourseVisit(id: String, visitsNumber: Int): CourseVisit
  updateForum(id: String, text: String): Forum
  updateLesson(assignment: Boolean, audience: String, challenge_num: Int, change: String, description: String, hasSecret: Boolean, id: String, name: String, number: Int, open: Boolean, short_structure: LessonStructure, structure: LessonStructure, tariffs: String, text: String, totalPoints: Int, type: String): Lesson
  updateLessonResult(id: String, progress: Int, visitsNumber: Int): LessonResult
  updateMiniStatement(comments: [String], id: String): Statement
  updateNewTest(answers: [String], comments: [String], complexity: Int, correct: [Boolean], id: String, ifRight: String, ifWrong: String, next: NextType, question: [String], type: String): NewTest
  updateNote(complexity: Int, id: String, isSecret: Boolean, link_clicks: Int, next: NextType, text: String): Note
  updateOrder(id: String, isPaid: Boolean): Order
  updateOrderAuto(id: String, userId: String): Order
  updatePost(id: String, image: String, likes: Int, summary: String, tags: [String], text: String, title: String): Post
  updateProblem(complexity: Int, id: String, isSecret: Boolean, text: String): Problem
  updateProgram(audience: String, authors: String, currency: String, description: String, goals: [String], header: [String], id: String, image: String, methods: String, news: String, nextStart: DateTime, price: Int, result: String, subheader: [String], title: String, video: String): Program
  updatePublished(id: String, published: Boolean): Lesson
  updateQuiz(answer: String, check: String, complexity: Int, id: String, ifRight: String, ifWrong: String, lessonId: String, next: NextType, question: String): Quiz
  updateRating(id: String, rating: Int): Rating
  updateShot(comments: [String], id: String, parts: [String], title: String): Shot
  updateStatement(comments: [String], id: String): Statement
  updateStatementChecked(answered: Boolean, id: String): Statement
  updateTextEditor(complexity: Int, id: String, name: String, text: String, totalMistakes: Int): TextEditor
  updateUser(description: String, email: String, id: String, image: String, isFamiliar: Boolean, name: String, number: String, status: Status, surname: String, tags: [String], work: String): User
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedEnumCourseTypeNullableFilter {
  equals: CourseType
  in: [CourseType!]
  not: NestedEnumCourseTypeNullableFilter
  notIn: [CourseType!]
}

input NestedEnumLevelNullableFilter {
  equals: Level
  in: [Level!]
  not: NestedEnumLevelNullableFilter
  notIn: [Level!]
}

input NestedEnumPageViewFilter {
  equals: PageView
  in: [PageView!]
  not: NestedEnumPageViewFilter
  notIn: [PageView!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type NewTest {
  answers: [String!]!
  comments: [String!]!
  complexity: Int
  correct: [Boolean!]!
  createdAt: DateTime!
  id: String!
  ifRight: String
  ifWrong: String
  lesson: Lesson
  lessonId: String
  lessonID: String
  next: Json
  question: [String!]!
  testResults(after: TestResultWhereUniqueInput, before: TestResultWhereUniqueInput, first: Int, last: Int): [TestResult!]!
  type: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input NewTestListRelationFilter {
  every: NewTestWhereInput
  none: NewTestWhereInput
  some: NewTestWhereInput
}

input NewTestWhereInput {
  AND: [NewTestWhereInput!]
  answers: StringNullableListFilter
  comments: StringNullableListFilter
  complexity: IntNullableFilter
  correct: BoolNullableListFilter
  createdAt: DateTimeFilter
  id: StringFilter
  ifRight: StringNullableFilter
  ifWrong: StringNullableFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  next: JsonNullableFilter
  NOT: [NewTestWhereInput!]
  OR: [NewTestWhereInput!]
  question: StringNullableListFilter
  testResults: TestResultListRelationFilter
  type: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input NewTestWhereUniqueInput {
  id: String
}

input NextFalseType {
  type: String
  value: String
}

input NextTrueType {
  type: String
  value: String
}

input NextType {
  false: NextFalseType
  true: NextTrueType
}

type Note {
  complexity: Int
  createdAt: DateTime!
  id: String!
  isSecret: Boolean
  lesson: Lesson
  lessonId: String
  lessonID: String
  link_clicks: Int
  next: Json
  text: String!
  updatedAt: DateTime!
  user: User
  userId: String
}

input NoteListRelationFilter {
  every: NoteWhereInput
  none: NoteWhereInput
  some: NoteWhereInput
}

input NoteWhereInput {
  AND: [NoteWhereInput!]
  chat: BoolNullableFilter
  complexity: IntNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  isSecret: BoolNullableFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  link_clicks: IntNullableFilter
  next: JsonNullableFilter
  NOT: [NoteWhereInput!]
  OR: [NoteWhereInput!]
  text: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringNullableFilter
}

input NoteWhereUniqueInput {
  id: String
}

type Offer {
  courseId: String
  createdAt: DateTime!
  discountPrice: Int
  header: String!
  id: String!
  lesson: Lesson
  lessonId: String
  price: Int
  text: String!
  type: String
  updatedAt: DateTime!
  user: User
  userId: String
}

input OfferListRelationFilter {
  every: OfferWhereInput
  none: OfferWhereInput
  some: OfferWhereInput
}

input OfferOrderByInput {
  courseId: SortOrder
  createdAt: SortOrder
  discountPrice: SortOrder
  header: SortOrder
  id: SortOrder
  lessonId: SortOrder
  price: SortOrder
  text: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input OfferWhereInput {
  AND: [OfferWhereInput!]
  courseId: StringNullableFilter
  createdAt: DateTimeFilter
  discountPrice: IntNullableFilter
  header: StringFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  NOT: [OfferWhereInput!]
  OR: [OfferWhereInput!]
  price: IntNullableFilter
  text: StringFilter
  type: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringNullableFilter
}

input OfferWhereUniqueInput {
  id: String
}

type Order {
  comment: String
  coursePage: CoursePage!
  coursePageId: String!
  createdAt: DateTime!
  id: String!
  isPaid: Boolean
  level: Level
  paymentID: String
  price: Int
  promocode: String
  team: Team
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input OrderListRelationFilter {
  every: OrderWhereInput
  none: OrderWhereInput
  some: OrderWhereInput
}

input OrderOrderByInput {
  comment: SortOrder
  coursePageId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  isPaid: SortOrder
  level: SortOrder
  paymentID: SortOrder
  price: SortOrder
  programId: SortOrder
  promocode: SortOrder
  teamId: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input OrderWhereInput {
  AND: [OrderWhereInput!]
  comment: StringNullableFilter
  coursePage: CoursePageWhereInput
  coursePageId: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  isPaid: BoolNullableFilter
  level: EnumLevelNullableFilter
  NOT: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  paymentID: StringNullableFilter
  price: IntNullableFilter
  program: ProgramWhereInput
  programId: StringNullableFilter
  promocode: StringNullableFilter
  team: TeamWhereInput
  teamId: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input OrderWhereUniqueInput {
  id: String
}

enum PageView {
  CONF
  COURSE
}

type PaymentInfo {
  order: Order
  url: String
}

type PaymentInfo2 {
  communityMember: CommunityMember
  url: String
}

"""The first Star Wars episodes released"""
enum Permission {
  ADMIN
  USER
}

input PointAListRelationFilter {
  every: PointAWhereInput
  none: PointAWhereInput
  some: PointAWhereInput
}

input PointATestListRelationFilter {
  every: PointATestWhereInput
  none: PointATestWhereInput
  some: PointATestWhereInput
}

input PointATestWhereInput {
  AND: [PointATestWhereInput!]
  answer1: StringFilter
  answer1Correct: StringFilter
  answer2: StringFilter
  answer2Correct: StringFilter
  answer3: StringNullableFilter
  answer3Correct: StringNullableFilter
  answer4: StringNullableFilter
  answer4Correct: StringNullableFilter
  coursePage: CoursePageWhereInput
  coursePageId: StringNullableFilter
  coursePageID: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [PointATestWhereInput!]
  OR: [PointATestWhereInput!]
  pointA: PointAListRelationFilter
  question: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input PointAWhereInput {
  AND: [PointAWhereInput!]
  coursePage: CoursePageWhereInput
  coursePageId: StringFilter
  coursePageID: StringNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: StringFilter
  NOT: [PointAWhereInput!]
  OR: [PointAWhereInput!]
  pointATest: PointATestListRelationFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

type Post {
  coursePage: CoursePage
  createdAt: DateTime!
  id: String!
  image: String
  language: String
  likes: Int
  summary: String
  tags: [String!]!
  text: String
  title: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

input PostOrderByInput {
  coursePageId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  image: SortOrder
  language: SortOrder
  likes: SortOrder
  summary: SortOrder
  tags: SortOrder
  text: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostWhereInput {
  AND: [PostWhereInput!]
  coursePage: CoursePageWhereInput
  coursePageId: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  image: StringNullableFilter
  language: StringNullableFilter
  likes: IntNullableFilter
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  summary: StringNullableFilter
  tags: StringNullableListFilter
  text: StringNullableFilter
  title: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input PostWhereUniqueInput {
  id: String
}

input Price {
  buttonText: String
  currency: String
  description: String
  discount: Float
  name: String
  places: Int
  price: Int
  timer: String
}

input Prices {
  prices: [Price]
}

type Problem {
  complexity: Int
  createdAt: DateTime!
  id: String!
  isSecret: Boolean
  lesson: Lesson!
  lessonId: String!
  lessonID: String!
  nodeID: String
  nodeType: String
  problemResults(after: ProblemResultWhereUniqueInput, before: ProblemResultWhereUniqueInput, first: Int, last: Int): [ProblemResult!]!
  steps: Json
  text: String!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input ProblemItem {
  id: String
  next: NextType
  type: String
}

input ProblemListRelationFilter {
  every: ProblemWhereInput
  none: ProblemWhereInput
  some: ProblemWhereInput
}

type ProblemResult {
  answer: String
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  lessonId: String
  lessonID: String
  problem: Problem
  problemId: String
  problemID: String
  revealed: [String!]!
  student: User!
  studentId: String!
  updatedAt: DateTime!
}

input ProblemResultListRelationFilter {
  every: ProblemResultWhereInput
  none: ProblemResultWhereInput
  some: ProblemResultWhereInput
}

input ProblemResultOrderByInput {
  answer: SortOrder
  createdAt: SortOrder
  id: SortOrder
  lessonId: SortOrder
  lessonID: SortOrder
  problemId: SortOrder
  problemID: SortOrder
  revealed: SortOrder
  studentId: SortOrder
  updatedAt: SortOrder
}

input ProblemResultWhereInput {
  AND: [ProblemResultWhereInput!]
  answer: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  NOT: [ProblemResultWhereInput!]
  OR: [ProblemResultWhereInput!]
  problem: ProblemWhereInput
  problemId: StringNullableFilter
  problemID: StringNullableFilter
  revealed: StringNullableListFilter
  student: UserWhereInput
  studentId: StringFilter
  updatedAt: DateTimeFilter
}

input ProblemResultWhereUniqueInput {
  id: String
}

input ProblemStructure {
  problemItems: [ProblemItem]
}

input ProblemWhereInput {
  AND: [ProblemWhereInput!]
  answer: StringNullableFilter
  complexity: IntNullableFilter
  createdAt: DateTimeFilter
  hints: StringNullableFilter
  hintsList: StringNullableListFilter
  id: StringFilter
  isSecret: BoolNullableFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  lessonID: StringFilter
  nodeID: StringNullableFilter
  nodeType: StringNullableFilter
  NOT: [ProblemWhereInput!]
  OR: [ProblemWhereInput!]
  problemResults: ProblemResultListRelationFilter
  solution: StringNullableFilter
  solutionList: StringNullableListFilter
  steps: JsonNullableFilter
  text: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input ProblemWhereUniqueInput {
  id: String
}

type Program {
  audience: String
  batch: String
  coursePages(after: CoursePageWhereUniqueInput, before: CoursePageWhereUniqueInput, first: Int, last: Int): [CoursePage!]!
  createdAt: DateTime!
  currency: String
  description: String!
  discountPrice: Int
  goals: [String!]!
  header: [String!]!
  id: String!
  image: String!
  installments: Int
  methods: String
  news: String
  nextStart: DateTime
  orders(after: OrderWhereUniqueInput, before: OrderWhereUniqueInput, first: Int, last: Int): [Order!]!
  price: Int
  promocode: Json
  published: Boolean
  result: String
  reviews: Json
  subheader: [String!]!
  tags: [String!]!
  tariffs: String
  title: String!
  updatedAt: DateTime!
  uptodateAt: DateTime
  video: String
}

input ProgramListRelationFilter {
  every: ProgramWhereInput
  none: ProgramWhereInput
  some: ProgramWhereInput
}

input ProgramOrderByInput {
  audience: SortOrder
  batch: SortOrder
  createdAt: SortOrder
  currency: SortOrder
  description: SortOrder
  discountPrice: SortOrder
  goals: SortOrder
  header: SortOrder
  id: SortOrder
  image: SortOrder
  installments: SortOrder
  methods: SortOrder
  news: SortOrder
  nextStart: SortOrder
  price: SortOrder
  promocode: SortOrder
  published: SortOrder
  result: SortOrder
  reviews: SortOrder
  subheader: SortOrder
  tags: SortOrder
  tariffs: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  uptodateAt: SortOrder
  video: SortOrder
}

input ProgramWhereInput {
  AND: [ProgramWhereInput!]
  audience: StringNullableFilter
  batch: StringNullableFilter
  coursePages: CoursePageListRelationFilter
  createdAt: DateTimeFilter
  currency: StringNullableFilter
  description: StringFilter
  discountPrice: IntNullableFilter
  goals: StringNullableListFilter
  header: StringNullableListFilter
  id: StringFilter
  image: StringFilter
  installments: IntNullableFilter
  methods: StringNullableFilter
  news: StringNullableFilter
  nextStart: DateTimeNullableFilter
  NOT: [ProgramWhereInput!]
  OR: [ProgramWhereInput!]
  orders: OrderListRelationFilter
  price: IntNullableFilter
  promocode: JsonNullableFilter
  published: BoolNullableFilter
  result: StringNullableFilter
  reviews: JsonNullableFilter
  subheader: StringNullableListFilter
  tags: StringNullableListFilter
  tariffs: StringNullableFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  uptodateAt: DateTimeNullableFilter
  video: StringNullableFilter
}

input ProgramWhereUniqueInput {
  id: String
}

input Promocode {
  name: String
  value: Float
}

input PromocodeList {
  promocodes: [Promocode]
}

type Query {
  businessClients(after: BusinessClientWhereUniqueInput, before: BusinessClientWhereUniqueInput, first: Int, last: Int, orderBy: [BusinessClientOrderByInput!], where: BusinessClientWhereInput): [BusinessClient!]!
  certificate(where: CertificateWhereUniqueInput!): Certificate
  certificates(after: CertificateWhereUniqueInput, before: CertificateWhereUniqueInput, first: Int, last: Int, orderBy: [CertificateOrderByInput!], where: CertificateWhereInput): [Certificate!]!
  challengeResults(after: ChallengeResultWhereUniqueInput, before: ChallengeResultWhereUniqueInput, first: Int, last: Int, orderBy: [ChallengeResultOrderByInput!], where: ChallengeResultWhereInput): [ChallengeResult!]!
  chat(where: ChatWhereUniqueInput!): Chat
  chats(after: ChatWhereUniqueInput, before: ChatWhereUniqueInput, first: Int, last: Int, orderBy: [ChatOrderByInput!], where: ChatWhereInput): [Chat!]!
  coursePage(where: CoursePageWhereUniqueInput!): CoursePage
  coursePages(after: CoursePageWhereUniqueInput, before: CoursePageWhereUniqueInput, first: Int, last: Int, orderBy: [CoursePageOrderByInput!], where: CoursePageWhereInput): [CoursePage!]!
  courseVisit(where: CourseVisitWhereUniqueInput!): CourseVisit
  courseVisits(after: CourseVisitWhereUniqueInput, before: CourseVisitWhereUniqueInput, first: Int, last: Int, orderBy: [CourseVisitOrderByInput!], where: CourseVisitWhereInput): [CourseVisit!]!
  feedbacks(after: FeedbackWhereUniqueInput, before: FeedbackWhereUniqueInput, first: Int, last: Int, orderBy: [FeedbackOrderByInput!], where: FeedbackWhereInput): [Feedback!]!
  lawrdle(where: LawrdleWhereUniqueInput!): Lawrdle
  lawrdles(after: LawrdleWhereUniqueInput, before: LawrdleWhereUniqueInput, first: Int, last: Int, orderBy: [LawrdleOrderByInput!], where: LawrdleWhereInput): [Lawrdle!]!
  lesson(where: LessonWhereUniqueInput!): Lesson
  lessonResults(after: LessonResultWhereUniqueInput, before: LessonResultWhereUniqueInput, first: Int, last: Int, orderBy: [LessonResultOrderByInput!], where: LessonResultWhereInput): [LessonResult!]!
  lessons(after: LessonWhereUniqueInput, before: LessonWhereUniqueInput, first: Int, last: Int, where: LessonWhereInput): [Lesson!]!
  me: User
  miniForums(after: MiniForumWhereUniqueInput, before: MiniForumWhereUniqueInput, first: Int, last: Int, where: MiniForumWhereInput): [MiniForum!]!
  newTest(where: NewTestWhereUniqueInput!): NewTest
  offer(where: OfferWhereUniqueInput!): Offer
  offers(after: OfferWhereUniqueInput, before: OfferWhereUniqueInput, first: Int, last: Int, orderBy: [OfferOrderByInput!], where: OfferWhereInput): [Offer!]!
  orders(after: OrderWhereUniqueInput, before: OrderWhereUniqueInput, first: Int, last: Int, orderBy: [OrderOrderByInput!], where: OrderWhereInput): [Order!]!
  post(where: PostWhereUniqueInput!): Post
  posts(after: PostWhereUniqueInput, before: PostWhereUniqueInput, first: Int, last: Int, orderBy: [PostOrderByInput!], where: PostWhereInput): [Post!]!
  problemResults(after: ProblemResultWhereUniqueInput, before: ProblemResultWhereUniqueInput, first: Int, last: Int, orderBy: [ProblemResultOrderByInput!], where: ProblemResultWhereInput): [ProblemResult!]!
  program(where: ProgramWhereUniqueInput!): Program
  programs(after: ProgramWhereUniqueInput, before: ProgramWhereUniqueInput, first: Int, last: Int, orderBy: [ProgramOrderByInput!], where: ProgramWhereInput): [Program!]!
  questResults(lessonId: String, list_of_ids: [String]): QuestResults
  quizResult(where: QuizResultWhereUniqueInput!): QuizResult
  quizResults(after: QuizResultWhereUniqueInput, before: QuizResultWhereUniqueInput, first: Int, last: Int, orderBy: [QuizResultOrderByInput!], where: QuizResultWhereInput): [QuizResult!]!
  quizzes(after: QuizWhereUniqueInput, before: QuizWhereUniqueInput, first: Int, last: Int, orderBy: [QuizOrderByInput!], where: QuizWhereInput): [Quiz!]!
  stats(lessonId: String, userId: String): Stats
  team(where: TeamWhereUniqueInput!): Team
  teams(after: TeamWhereUniqueInput, before: TeamWhereUniqueInput, first: Int, last: Int, orderBy: [TeamOrderByInput!], where: TeamWhereInput): [Team!]!
  testResult(where: TestResultWhereUniqueInput!): TestResult
  testResults(after: TestResultWhereUniqueInput, before: TestResultWhereUniqueInput, first: Int, last: Int, orderBy: [TestResultOrderByInput!], where: TestResultWhereInput): [TestResult!]!
  textEditorResult(where: TextEditorResultWhereUniqueInput!): TextEditorResult
  textEditorResults(after: TextEditorResultWhereUniqueInput, before: TextEditorResultWhereUniqueInput, first: Int, last: Int, orderBy: [TextEditorResultOrderByInput!], where: TextEditorResultWhereInput): [TextEditorResult!]!
  useful(where: UsefulWhereUniqueInput!): Useful
  usefuls(after: UsefulWhereUniqueInput, before: UsefulWhereUniqueInput, first: Int, last: Int, where: UsefulWhereInput): [Useful!]!
  user(where: UserWhereUniqueInput!): User
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, orderBy: [UserOrderByInput!], where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

input QuestElement {
  number: Int
  type: String
  value: String
}

input QuestList {
  questElements: [QuestElement]
}

type QuestResults {
  lessonResults: [LessonResult]
  quizResults: [QuizResult]
  testResults: [TestResult]
}

type Quiz {
  answer: String!
  check: String
  complexity: Int
  createdAt: DateTime!
  id: String!
  ifRight: String
  ifWrong: String
  lesson: Lesson
  lessonId: String
  lessonID: String
  next: Json
  question: String!
  quizResults(after: QuizResultWhereUniqueInput, before: QuizResultWhereUniqueInput, first: Int, last: Int): [QuizResult!]!
  type: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input QuizListRelationFilter {
  every: QuizWhereInput
  none: QuizWhereInput
  some: QuizWhereInput
}

input QuizOrderByInput {
  answer: SortOrder
  check: SortOrder
  complexity: SortOrder
  createdAt: SortOrder
  id: SortOrder
  ifRight: SortOrder
  ifWrong: SortOrder
  lessonId: SortOrder
  lessonID: SortOrder
  next: SortOrder
  question: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type QuizResult {
  answer: String
  attempts: Int
  correct: Boolean
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  lessonId: String
  lessonID: String
  quiz: Quiz
  quizId: String
  student: User!
  studentId: String!
  updatedAt: DateTime!
}

input QuizResultListRelationFilter {
  every: QuizResultWhereInput
  none: QuizResultWhereInput
  some: QuizResultWhereInput
}

input QuizResultOrderByInput {
  answer: SortOrder
  attempts: SortOrder
  correct: SortOrder
  createdAt: SortOrder
  id: SortOrder
  lessonId: SortOrder
  lessonID: SortOrder
  quizId: SortOrder
  studentId: SortOrder
  updatedAt: SortOrder
}

input QuizResultWhereInput {
  AND: [QuizResultWhereInput!]
  answer: StringNullableFilter
  attempts: IntNullableFilter
  correct: BoolNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  NOT: [QuizResultWhereInput!]
  OR: [QuizResultWhereInput!]
  quiz: QuizWhereInput
  quizId: StringNullableFilter
  student: UserWhereInput
  studentId: StringFilter
  updatedAt: DateTimeFilter
}

input QuizResultWhereUniqueInput {
  id: String
}

input QuizWhereInput {
  AND: [QuizWhereInput!]
  answer: StringFilter
  check: StringNullableFilter
  complexity: IntNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  ifRight: StringNullableFilter
  ifWrong: StringNullableFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  next: JsonNullableFilter
  NOT: [QuizWhereInput!]
  OR: [QuizWhereInput!]
  question: StringFilter
  quizResults: QuizResultListRelationFilter
  type: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input QuizWhereUniqueInput {
  id: String
}

type Rating {
  createdAt: DateTime!
  forum: Forum
  forumId: String
  id: String!
  rating: Int
  updatedAt: DateTime!
  user: User
  userId: String
}

input RatingListRelationFilter {
  every: RatingWhereInput
  none: RatingWhereInput
  some: RatingWhereInput
}

input RatingWhereInput {
  AND: [RatingWhereInput!]
  createdAt: DateTimeFilter
  forum: ForumWhereInput
  forumId: StringNullableFilter
  id: StringFilter
  NOT: [RatingWhereInput!]
  OR: [RatingWhereInput!]
  rating: IntNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringNullableFilter
}

input RatingWhereUniqueInput {
  id: String
}

input Reaction {
  comment: String
  image: String
  name: String
  reaction: String
}

input SalesCycle {
  stages: [SalesStage]
}

input SalesStage {
  date: String
  name: String
}

input SandboxListRelationFilter {
  every: SandboxWhereInput
  none: SandboxWhereInput
  some: SandboxWhereInput
}

input SandboxPageGoalListRelationFilter {
  every: SandboxPageGoalWhereInput
  none: SandboxPageGoalWhereInput
  some: SandboxPageGoalWhereInput
}

input SandboxPageGoalWhereInput {
  AND: [SandboxPageGoalWhereInput!]
  completed: BoolFilter
  createdAt: DateTimeFilter
  goal: StringFilter
  id: StringFilter
  NOT: [SandboxPageGoalWhereInput!]
  OR: [SandboxPageGoalWhereInput!]
  sandboxPage: SandboxPageWhereInput
  sandboxPageId: StringNullableFilter
  sandboxPageID: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input SandboxPageListRelationFilter {
  every: SandboxPageWhereInput
  none: SandboxPageWhereInput
  some: SandboxPageWhereInput
}

input SandboxPageWhereInput {
  AND: [SandboxPageWhereInput!]
  createdAt: DateTimeFilter
  description: StringFilter
  id: StringFilter
  image: StringFilter
  NOT: [SandboxPageWhereInput!]
  OR: [SandboxPageWhereInput!]
  sandbox: SandboxListRelationFilter
  sandboxPageGoal: SandboxPageGoalListRelationFilter
  students: StringNullableListFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input SandboxWhereInput {
  AND: [SandboxWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  likes: IntNullableFilter
  link: StringNullableFilter
  NOT: [SandboxWhereInput!]
  OR: [SandboxWhereInput!]
  sandboxPage: SandboxPageWhereInput
  sandboxPageId: StringFilter
  sandboxPageID: StringFilter
  text: StringFilter
  updatedAt: DateTimeFilter
  video: StringNullableFilter
}

type Shot {
  comments: [String!]!
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  lessonId: String
  lessonID: String
  parts: [String!]!
  shotResults(after: ShotResultWhereUniqueInput, before: ShotResultWhereUniqueInput, first: Int, last: Int): [ShotResult!]!
  title: String!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input ShotListRelationFilter {
  every: ShotWhereInput
  none: ShotWhereInput
  some: ShotWhereInput
}

type ShotResult {
  answer: String!
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  lessonId: String
  shot: Shot
  shotId: String
  student: User!
  studentId: String!
  updatedAt: DateTime!
}

input ShotResultListRelationFilter {
  every: ShotResultWhereInput
  none: ShotResultWhereInput
  some: ShotResultWhereInput
}

input ShotResultWhereInput {
  AND: [ShotResultWhereInput!]
  answer: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  NOT: [ShotResultWhereInput!]
  OR: [ShotResultWhereInput!]
  shot: ShotWhereInput
  shotId: StringNullableFilter
  shotID: StringNullableFilter
  student: UserWhereInput
  studentId: StringFilter
  updatedAt: DateTimeFilter
}

input ShotResultWhereUniqueInput {
  id: String
}

input ShotWhereInput {
  AND: [ShotWhereInput!]
  comments: StringNullableListFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  NOT: [ShotWhereInput!]
  OR: [ShotWhereInput!]
  parts: StringNullableListFilter
  shotResults: ShotResultListRelationFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input ShotWhereUniqueInput {
  id: String
}

type SignOut {
  message: String
}

enum SortOrder {
  asc
  desc
}

type Statement {
  answered: Boolean
  comments: [String!]!
  createdAt: DateTime!
  forum: Forum
  forumId: String
  id: String!
  text: String
  updatedAt: DateTime!
  user: User
  userId: String
}

input StatementListRelationFilter {
  every: StatementWhereInput
  none: StatementWhereInput
  some: StatementWhereInput
}

input StatementWhereInput {
  AND: [StatementWhereInput!]
  answered: BoolNullableFilter
  comments: StringNullableListFilter
  createdAt: DateTimeFilter
  forum: ForumWhereInput
  forumId: StringNullableFilter
  id: StringFilter
  miniforum: MiniForumWhereInput
  miniforumId: StringNullableFilter
  NOT: [StatementWhereInput!]
  OR: [StatementWhereInput!]
  text: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringNullableFilter
}

input StatementWhereUniqueInput {
  id: String
}

type Stats {
  constructionResults: [ConstructionResult]
  documentResults: [DocumentResult]
  feedbacks: [Feedback]
  problemResults: [ProblemResult]
  quizResults: [QuizResult]
  testResults: [TestResult]
  textEditorResults: [TextEditorResult]
}

"""The first Star Wars episodes released"""
enum Status {
  AUTHOR
  HR
  LAWYER
  SAVVY_AUTHOR
  STUDENT
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
}

type Team {
  createdAt: DateTime!
  founder: User!
  id: String!
  image: String
  name: String!
  orders(after: OrderWhereUniqueInput, before: OrderWhereUniqueInput, first: Int, last: Int): [Order!]!
  updatedAt: DateTime!
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
}

input TeamListRelationFilter {
  every: TeamWhereInput
  none: TeamWhereInput
  some: TeamWhereInput
}

input TeamOrderByInput {
  createdAt: SortOrder
  founderId: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type TeamQuest {
  createdAt: DateTime!
  id: String!
  introduction: String!
  lesson: Lesson!
  lessonId: String!
  solution: String
  tasks: Json!
  teamQuestResults(after: TeamQuestResultWhereUniqueInput, before: TeamQuestResultWhereUniqueInput, first: Int, last: Int): [TeamQuestResult!]!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input TeamQuestListRelationFilter {
  every: TeamQuestWhereInput
  none: TeamQuestWhereInput
  some: TeamQuestWhereInput
}

type TeamQuestResult {
  answer: String
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  lessonId: String
  student: User!
  studentId: String!
  teamQuest: TeamQuest
  teamQuestId: String
  updatedAt: DateTime!
}

input TeamQuestResultListRelationFilter {
  every: TeamQuestResultWhereInput
  none: TeamQuestResultWhereInput
  some: TeamQuestResultWhereInput
}

input TeamQuestResultWhereInput {
  AND: [TeamQuestResultWhereInput!]
  answer: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  NOT: [TeamQuestResultWhereInput!]
  OR: [TeamQuestResultWhereInput!]
  student: UserWhereInput
  studentId: StringFilter
  teamQuest: TeamQuestWhereInput
  teamQuestId: StringNullableFilter
  updatedAt: DateTimeFilter
}

input TeamQuestResultWhereUniqueInput {
  id: String
}

input TeamQuestWhereInput {
  AND: [TeamQuestWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  introduction: StringFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  NOT: [TeamQuestWhereInput!]
  OR: [TeamQuestWhereInput!]
  solution: StringNullableFilter
  teamQuestResults: TeamQuestResultListRelationFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input TeamQuestWhereUniqueInput {
  id: String
}

input TeamWhereInput {
  AND: [TeamWhereInput!]
  createdAt: DateTimeFilter
  founder: UserWhereInput
  founderId: StringFilter
  id: StringFilter
  image: StringNullableFilter
  name: StringFilter
  NOT: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  orders: OrderListRelationFilter
  updatedAt: DateTimeFilter
  users: UserListRelationFilter
}

input TeamWhereUniqueInput {
  id: String
}

input TestListRelationFilter {
  every: TestWhereInput
  none: TestWhereInput
  some: TestWhereInput
}

type TestPractice {
  createdAt: DateTime!
  failureText: String
  id: String!
  intro: String
  lessonId: String
  successText: String
  tasks: [String!]!
  tasksNum: Int!
  text: String
  updatedAt: DateTime!
}

input TestPracticeListRelationFilter {
  every: TestPracticeWhereInput
  none: TestPracticeWhereInput
  some: TestPracticeWhereInput
}

type TestPracticeResult {
  correct: Int!
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  lessonId: String
  student: User!
  studentId: String!
  tasks: [String!]!
  testPractice: TestPractice
  testPracticeId: String
  updatedAt: DateTime!
}

input TestPracticeResultListRelationFilter {
  every: TestPracticeResultWhereInput
  none: TestPracticeResultWhereInput
  some: TestPracticeResultWhereInput
}

input TestPracticeResultWhereInput {
  AND: [TestPracticeResultWhereInput!]
  correct: IntFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  NOT: [TestPracticeResultWhereInput!]
  OR: [TestPracticeResultWhereInput!]
  student: UserWhereInput
  studentId: StringFilter
  tasks: StringNullableListFilter
  testPractice: TestPracticeWhereInput
  testPracticeId: StringNullableFilter
  updatedAt: DateTimeFilter
}

input TestPracticeWhereInput {
  AND: [TestPracticeWhereInput!]
  createdAt: DateTimeFilter
  failureText: StringNullableFilter
  id: StringFilter
  intro: StringNullableFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  NOT: [TestPracticeWhereInput!]
  OR: [TestPracticeWhereInput!]
  successText: StringNullableFilter
  tasks: StringNullableListFilter
  tasksNum: IntFilter
  testPracticeResults: TestPracticeResultListRelationFilter
  text: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringNullableFilter
}

input TestPracticeWhereUniqueInput {
  id: String
}

type TestResult {
  answer: String
  attempts: Int
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  lessonId: String
  lessonID: String
  student: User!
  studentId: String!
  test: NewTest
  testId: String
  testID: String
  updatedAt: DateTime!
}

input TestResultListRelationFilter {
  every: TestResultWhereInput
  none: TestResultWhereInput
  some: TestResultWhereInput
}

input TestResultOrderByInput {
  answer: SortOrder
  attempts: SortOrder
  createdAt: SortOrder
  id: SortOrder
  lessonId: SortOrder
  lessonID: SortOrder
  studentId: SortOrder
  testId: SortOrder
  testID: SortOrder
  updatedAt: SortOrder
}

input TestResultWhereInput {
  AND: [TestResultWhereInput!]
  answer: StringNullableFilter
  attempts: IntNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  NOT: [TestResultWhereInput!]
  OR: [TestResultWhereInput!]
  student: UserWhereInput
  studentId: StringFilter
  test: NewTestWhereInput
  testId: StringNullableFilter
  testID: StringNullableFilter
  updatedAt: DateTimeFilter
}

input TestResultWhereUniqueInput {
  id: String
}

input TestWhereInput {
  AND: [TestWhereInput!]
  answer1: StringFilter
  answer1Correct: StringFilter
  answer2: StringFilter
  answer2Correct: StringFilter
  answer3: StringNullableFilter
  answer3Correct: StringNullableFilter
  answer4: StringNullableFilter
  answer4Correct: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  NOT: [TestWhereInput!]
  OR: [TestWhereInput!]
  question: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

type TextEditor {
  complexity: Int
  createdAt: DateTime!
  id: String!
  lesson: Lesson!
  lessonId: String!
  lessonID: String!
  name: String!
  text: String!
  textEditorResults(after: TextEditorResultWhereUniqueInput, before: TextEditorResultWhereUniqueInput, first: Int, last: Int): [TextEditorResult!]!
  totalMistakes: Int
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input TextEditorListRelationFilter {
  every: TextEditorWhereInput
  none: TextEditorWhereInput
  some: TextEditorWhereInput
}

type TextEditorResult {
  attempts: Int
  correct: String
  createdAt: DateTime!
  guess: String!
  id: String!
  lesson: Lesson
  lessonId: String
  result: Boolean
  student: User!
  studentId: String!
  textEditor: TextEditor
  textEditorId: String
  type: String
  updatedAt: DateTime!
  wrong: String
}

input TextEditorResultListRelationFilter {
  every: TextEditorResultWhereInput
  none: TextEditorResultWhereInput
  some: TextEditorResultWhereInput
}

input TextEditorResultOrderByInput {
  attempts: SortOrder
  correct: SortOrder
  createdAt: SortOrder
  guess: SortOrder
  id: SortOrder
  lessonId: SortOrder
  result: SortOrder
  studentId: SortOrder
  textEditorId: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  wrong: SortOrder
}

input TextEditorResultWhereInput {
  AND: [TextEditorResultWhereInput!]
  attempts: IntNullableFilter
  correct: StringNullableFilter
  createdAt: DateTimeFilter
  guess: StringFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  NOT: [TextEditorResultWhereInput!]
  OR: [TextEditorResultWhereInput!]
  result: BoolNullableFilter
  student: UserWhereInput
  studentId: StringFilter
  textEditor: TextEditorWhereInput
  textEditorId: StringNullableFilter
  type: StringNullableFilter
  updatedAt: DateTimeFilter
  wrong: StringNullableFilter
}

input TextEditorResultWhereUniqueInput {
  id: String
}

input TextEditorWhereInput {
  AND: [TextEditorWhereInput!]
  complexity: IntNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  lessonID: StringFilter
  name: StringFilter
  NOT: [TextEditorWhereInput!]
  OR: [TextEditorWhereInput!]
  text: StringFilter
  textEditorResults: TextEditorResultListRelationFilter
  totalMistakes: IntNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input TextEditorWhereUniqueInput {
  id: String
}

type Uni {
  capacity: Int
  id: String!
  paidMonths: Int
  teachers(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
  title: String!
}

input UniWhereInput {
  AND: [UniWhereInput!]
  capacity: IntNullableFilter
  coursePage: CoursePageListRelationFilter
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [UniWhereInput!]
  OR: [UniWhereInput!]
  paidMonths: IntNullableFilter
  teachers: UserListRelationFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

type Useful {
  buttonText: String!
  createdAt: DateTime!
  header: String!
  id: String!
  image: String!
  link: String!
  tags: [String!]!
  updatedAt: DateTime!
}

input UsefulWhereInput {
  AND: [UsefulWhereInput!]
  buttonText: StringFilter
  createdAt: DateTimeFilter
  header: StringFilter
  id: StringFilter
  image: StringFilter
  link: StringFilter
  NOT: [UsefulWhereInput!]
  OR: [UsefulWhereInput!]
  tags: StringNullableListFilter
  updatedAt: DateTimeFilter
}

input UsefulWhereUniqueInput {
  id: String
}

type User {
  certificates(after: CertificateWhereUniqueInput, before: CertificateWhereUniqueInput, first: Int, last: Int): [Certificate!]!
  co_coursePages(after: CoursePageWhereUniqueInput, before: CoursePageWhereUniqueInput, first: Int, last: Int, orderBy: [UserCo_coursePagesOrderByInput!]): [CoursePage!]!
  comment: String
  company: Company
  country: String
  coursePages(after: CoursePageWhereUniqueInput, before: CoursePageWhereUniqueInput, first: Int, last: Int, orderBy: [UserCoursePagesOrderByInput!]): [CoursePage!]!
  courseVisits(after: CourseVisitWhereUniqueInput, before: CourseVisitWhereUniqueInput, first: Int, last: Int): [CourseVisit!]!
  createdAt: DateTime!
  description: String
  email: String!
  id: String!
  image: String
  lessonResults(after: LessonResultWhereUniqueInput, before: LessonResultWhereUniqueInput, first: Int, last: Int): [LessonResult!]!
  lessons(after: LessonWhereUniqueInput, before: LessonWhereUniqueInput, first: Int, last: Int): [Lesson!]!
  level: UserLevel
  messages(after: MessageWhereUniqueInput, before: MessageWhereUniqueInput, first: Int, last: Int): [Message!]!
  myTeams(after: TeamWhereUniqueInput, before: TeamWhereUniqueInput, first: Int, last: Int): [Team!]!
  name: String!
  new_subjects(after: CoursePageWhereUniqueInput, before: CoursePageWhereUniqueInput, first: Int, last: Int): [CoursePage!]!
  number: String
  orders(after: OrderWhereUniqueInput, before: OrderWhereUniqueInput, first: Int, last: Int): [Order!]!
  password: String!
  permissions: [Permission!]!
  resume: String
  status: String
  studentFeedback(after: FeedbackWhereUniqueInput, before: FeedbackWhereUniqueInput, first: Int, last: Int): [Feedback!]!
  surname: String
  tags: [String!]!
  teacherFeedback(after: FeedbackWhereUniqueInput, before: FeedbackWhereUniqueInput, first: Int, last: Int): [Feedback!]!
  teamQuestResults(after: TeamQuestResultWhereUniqueInput, before: TeamQuestResultWhereUniqueInput, first: Int, last: Int): [TeamQuestResult!]!
  teamQuests(after: TeamQuestWhereUniqueInput, before: TeamQuestWhereUniqueInput, first: Int, last: Int): [TeamQuest!]!
  teams(after: TeamWhereUniqueInput, before: TeamWhereUniqueInput, first: Int, last: Int): [Team!]!
  traffic_sources: Json
  uni: Uni
  updatedAt: DateTime!
  work: String
}

input UserCo_coursePagesOrderByInput {
  title: SortOrder
}

input UserCoursePagesOrderByInput {
  title: SortOrder
}

type UserLevel {
  createdAt: DateTime!
  id: String!
  level: Float
  updatedAt: DateTime!
  user: User
}

input UserLevelWhereInput {
  AND: [UserLevelWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  level: FloatNullableFilter
  NOT: [UserLevelWhereInput!]
  OR: [UserLevelWhereInput!]
  updatedAt: DateTimeFilter
  user: UserWhereInput
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByInput {
  careerTrackId: SortOrder
  careerTrackID: SortOrder
  comment: SortOrder
  companyId: SortOrder
  country: SortOrder
  coverLetter: SortOrder
  createdAt: SortOrder
  description: SortOrder
  email: SortOrder
  favourites: SortOrder
  id: SortOrder
  image: SortOrder
  isFamiliar: SortOrder
  legalPortfolioId: SortOrder
  levelId: SortOrder
  name: SortOrder
  number: SortOrder
  password: SortOrder
  permissions: SortOrder
  resetToken: SortOrder
  resetTokenExpiry: SortOrder
  resume: SortOrder
  status: SortOrder
  subjects: SortOrder
  surname: SortOrder
  tags: SortOrder
  traffic_sources: SortOrder
  uniId: SortOrder
  uniID: SortOrder
  updatedAt: SortOrder
  work: SortOrder
}

input UserWhereInput {
  AND: [UserWhereInput!]
  careerTrack: CareerTrackWhereInput
  careerTrackId: StringNullableFilter
  careerTrackID: StringNullableFilter
  certificates: CertificateListRelationFilter
  challengeResults: ChallengeResultListRelationFilter
  chats: ChatListRelationFilter
  clauses: ClauseListRelationFilter
  co_coursePages: CoursePageListRelationFilter
  comment: StringNullableFilter
  company: CompanyWhereInput
  companyId: StringNullableFilter
  constructionResults: ConstructionResultListRelationFilter
  constructions: ConstructionListRelationFilter
  country: StringNullableFilter
  coursePages: CoursePageListRelationFilter
  courseVisits: CourseVisitListRelationFilter
  coverLetter: StringNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  documentResults: DocumentResultListRelationFilter
  documents: DocumentListRelationFilter
  email: StringFilter
  examAnswers: ExamAnswerListRelationFilter
  examResults: ExamResultListRelationFilter
  exams: ExamListRelationFilter
  favourites: StringNullableListFilter
  forums: ForumListRelationFilter
  id: StringFilter
  image: StringNullableFilter
  isFamiliar: BoolFilter
  lawrdles: LawrdleListRelationFilter
  legalPortfolio: LegalPortfolioWhereInput
  legalPortfolioId: StringNullableFilter
  lessonResults: LessonResultListRelationFilter
  lessons: LessonListRelationFilter
  level: UserLevelWhereInput
  levelId: StringNullableFilter
  messages: MessageListRelationFilter
  miniforums: MiniForumListRelationFilter
  myTeams: TeamListRelationFilter
  name: StringFilter
  new_subjects: CoursePageListRelationFilter
  newTests: NewTestListRelationFilter
  NOT: [UserWhereInput!]
  notes: NoteListRelationFilter
  number: StringNullableFilter
  offers: OfferListRelationFilter
  OR: [UserWhereInput!]
  orders: OrderListRelationFilter
  password: StringFilter
  permissions: EnumPermissionNullableListFilter
  pointAs: PointAListRelationFilter
  pointATests: PointATestListRelationFilter
  posts: PostListRelationFilter
  problemResults: ProblemResultListRelationFilter
  problems: ProblemListRelationFilter
  quizes: QuizListRelationFilter
  quizResults: QuizResultListRelationFilter
  ratings: RatingListRelationFilter
  resetToken: StringNullableFilter
  resetTokenExpiry: FloatNullableFilter
  resume: StringNullableFilter
  sandboxPageGoals: SandboxPageGoalListRelationFilter
  sandboxPages: SandboxPageListRelationFilter
  shotResults: ShotResultListRelationFilter
  shots: ShotListRelationFilter
  statements: StatementListRelationFilter
  status: StringNullableFilter
  studentFeedback: FeedbackListRelationFilter
  subjects: StringNullableListFilter
  surname: StringNullableFilter
  tags: StringNullableListFilter
  teacherFeedback: FeedbackListRelationFilter
  teamQuestResults: TeamQuestResultListRelationFilter
  teamQuests: TeamQuestListRelationFilter
  teams: TeamListRelationFilter
  testPracticeResults: TestPracticeResultListRelationFilter
  testPractices: TestPracticeListRelationFilter
  testResults: TestResultListRelationFilter
  tests: TestListRelationFilter
  textEditorResults: TextEditorResultListRelationFilter
  textEditors: TextEditorListRelationFilter
  traffic_sources: JsonNullableFilter
  uni: UniWhereInput
  uniId: StringNullableFilter
  uniID: StringNullableFilter
  updatedAt: DateTimeFilter
  work: StringNullableFilter
}

input UserWhereUniqueInput {
  careerTrackId: String
  email: String
  id: String
  legalPortfolioId: String
  levelId: String
}

input Visit {
  date: String
  utm_campaign: String
  utm_medium: String
  utm_source: String
}

input Visits {
  visitsList: [Visit]
}
