### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Application {
  applicantId: String!
  createdAt: DateTime!
  id: String!
  updatedAt: DateTime!
}

input ApplicationListRelationFilter {
  every: ApplicationWhereInput
  none: ApplicationWhereInput
  some: ApplicationWhereInput
}

input ApplicationWhereInput {
  AND: [ApplicationWhereInput!]
  applicantId: StringFilter
  applicantName: StringFilter
  coursePage: CoursePageWhereInput
  coursePageId: StringFilter
  coursePageID: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  message: StringNullableFilter
  NOT: [ApplicationWhereInput!]
  OR: [ApplicationWhereInput!]
  updatedAt: DateTimeFilter
}

input ApplicationWhereUniqueInput {
  id: String
}

type AuthPayload {
  token: String
  user: User
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input BoolNullableListFilter {
  equals: [Boolean!]
}

type BusinessClient {
  communication_medium: String
  createdAt: DateTime!
  email: String!
  id: String!
  name: String
  number: String
  type: String
  updatedAt: DateTime!
}

input CareerTrackListRelationFilter {
  every: CareerTrackWhereInput
  none: CareerTrackWhereInput
  some: CareerTrackWhereInput
}

input CareerTrackUnitListRelationFilter {
  every: CareerTrackUnitWhereInput
  none: CareerTrackUnitWhereInput
  some: CareerTrackUnitWhereInput
}

input CareerTrackUnitWhereInput {
  AND: [CareerTrackUnitWhereInput!]
  articles: StringNullableListFilter
  careerTrack: CareerTrackWhereInput
  careerTrackId: StringFilter
  coursePages: CoursePageListRelationFilter
  createdAt: DateTimeFilter
  id: StringFilter
  img: StringNullableFilter
  NOT: [CareerTrackUnitWhereInput!]
  number: IntNullableFilter
  OR: [CareerTrackUnitWhereInput!]
  title: StringFilter
  topics: StringNullableListFilter
  updatedAt: DateTimeFilter
}

input CareerTrackWhereInput {
  AND: [CareerTrackWhereInput!]
  careerTrackUnits: CareerTrackUnitListRelationFilter
  coursePages: CoursePageListRelationFilter
  createdAt: DateTimeFilter
  id: StringFilter
  img: StringNullableFilter
  members: UserWhereInput
  name: StringFilter
  NOT: [CareerTrackWhereInput!]
  OR: [CareerTrackWhereInput!]
  updatedAt: DateTimeFilter
}

type ChallengeResult {
  correct: Int
  createdAt: DateTime!
  id: String!
  lesson: Lesson!
  lessonId: String!
  student: User!
  studentId: String!
  time: Int
  updatedAt: DateTime!
  wrong: Int
}

input ChallengeResultListRelationFilter {
  every: ChallengeResultWhereInput
  none: ChallengeResultWhereInput
  some: ChallengeResultWhereInput
}

input ChallengeResultWhereInput {
  AND: [ChallengeResultWhereInput!]
  correct: IntNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  NOT: [ChallengeResultWhereInput!]
  OR: [ChallengeResultWhereInput!]
  student: UserWhereInput
  studentId: StringFilter
  time: IntNullableFilter
  updatedAt: DateTimeFilter
  wrong: IntNullableFilter
}

input ChallengeResultWhereUniqueInput {
  id: String
}

type Chat {
  complexity: Int
  createdAt: DateTime!
  id: String!
  lesson: Lesson!
  lessonId: String!
  messages: Json
  name: String
  updatedAt: DateTime!
  user: User!
}

input ChatListRelationFilter {
  every: ChatWhereInput
  none: ChatWhereInput
  some: ChatWhereInput
}

input ChatWhereInput {
  AND: [ChatWhereInput!]
  complexity: IntNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  messages: JsonNullableFilter
  name: StringNullableFilter
  NOT: [ChatWhereInput!]
  OR: [ChatWhereInput!]
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input ChatWhereUniqueInput {
  id: String
}

type Clause {
  commentary: String!
  createdAt: DateTime!
  document: Document!
  documentId: String!
  id: String!
  keywords: [String!]!
  number: Int!
  sample: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input ClauseListRelationFilter {
  every: ClauseWhereInput
  none: ClauseWhereInput
  some: ClauseWhereInput
}

input ClauseWhereInput {
  AND: [ClauseWhereInput!]
  commentary: StringFilter
  createdAt: DateTimeFilter
  document: DocumentWhereInput
  documentId: StringFilter
  id: StringFilter
  keywords: StringNullableListFilter
  NOT: [ClauseWhereInput!]
  number: IntFilter
  OR: [ClauseWhereInput!]
  sample: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input ClauseWhereUniqueInput {
  id: String
}

type Company {
  id: String!
  name: String!
}

input CompanyWhereInput {
  AND: [CompanyWhereInput!]
  coursePage: CoursePageListRelationFilter
  createdAt: DateTimeFilter
  hrs: UserListRelationFilter
  id: StringFilter
  name: StringFilter
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  paidMonths: IntNullableFilter
  updatedAt: DateTimeFilter
}

type ConfUser {
  conf_number: Int
  createdAt: DateTime!
  email: String!
  id: String!
  name: String
  surname: String
  updatedAt: DateTime!
}

type Construction {
  answer: [String!]!
  complexity: Int
  constructionResults(after: ConstructionResultWhereUniqueInput, before: ConstructionResultWhereUniqueInput, first: Int, last: Int): [ConstructionResult!]!
  createdAt: DateTime!
  hasText: Boolean!
  hint: String
  id: String!
  lesson: Lesson!
  lessonId: String!
  lessonID: String!
  name: String!
  text: String
  type: String!
  updatedAt: DateTime!
  user: User!
  userId: String!
  variants: [String!]!
}

input ConstructionListRelationFilter {
  every: ConstructionWhereInput
  none: ConstructionWhereInput
  some: ConstructionWhereInput
}

type ConstructionResult {
  answer: String
  attempts: Int
  construction: Construction
  constructionId: String
  constructionID: String
  createdAt: DateTime!
  id: String!
  inputs: [String!]!
  lesson: Lesson
  lessonId: String
  lessonID: String
  student: User!
  studentId: String!
  updatedAt: DateTime!
}

input ConstructionResultListRelationFilter {
  every: ConstructionResultWhereInput
  none: ConstructionResultWhereInput
  some: ConstructionResultWhereInput
}

input ConstructionResultWhereInput {
  AND: [ConstructionResultWhereInput!]
  answer: StringNullableFilter
  attempts: IntNullableFilter
  construction: ConstructionWhereInput
  constructionId: StringNullableFilter
  constructionID: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  inputs: StringNullableListFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  NOT: [ConstructionResultWhereInput!]
  OR: [ConstructionResultWhereInput!]
  student: UserWhereInput
  studentId: StringFilter
  updatedAt: DateTimeFilter
}

input ConstructionResultWhereUniqueInput {
  id: String
}

input ConstructionWhereInput {
  AND: [ConstructionWhereInput!]
  answer: StringNullableListFilter
  complexity: IntNullableFilter
  constructionResults: ConstructionResultListRelationFilter
  createdAt: DateTimeFilter
  hasText: BoolFilter
  hint: StringNullableFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  lessonID: StringFilter
  name: StringFilter
  NOT: [ConstructionWhereInput!]
  OR: [ConstructionWhereInput!]
  text: StringNullableFilter
  type: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
  variants: StringNullableListFilter
}

input ConstructionWhereUniqueInput {
  id: String
}

type CoursePage {
  applications(after: ApplicationWhereUniqueInput, before: ApplicationWhereUniqueInput, first: Int, last: Int): [Application!]!
  audience: String
  authors(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
  banner: String
  batch: String
  company: Company
  courseType: CourseType
  createdAt: DateTime!
  description: String!
  discountPrice: Int
  id: String!
  image: String!
  lessons(after: LessonWhereUniqueInput, before: LessonWhereUniqueInput, first: Int, last: Int): [Lesson!]!
  methods: String
  new_students(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, where: UserWhereInput): [User!]!
  news: String
  price: Int
  promocode: Json
  published: Boolean
  result: String
  reviews: Json
  students: [String!]!
  subscription: Boolean
  subscriptionPrice: Int
  tags: [String!]!
  tariffs: String
  title: String!
  uni: Uni
  updatedAt: DateTime!
  user: User!
  video: String
  weeks: Int
}

input CoursePageListRelationFilter {
  every: CoursePageWhereInput
  none: CoursePageWhereInput
  some: CoursePageWhereInput
}

input CoursePageOrderByInput {
  audience: SortOrder
  banner: SortOrder
  batch: SortOrder
  companyId: SortOrder
  courseType: SortOrder
  createdAt: SortOrder
  description: SortOrder
  discountPrice: SortOrder
  examQuestionId: SortOrder
  id: SortOrder
  image: SortOrder
  methods: SortOrder
  news: SortOrder
  numInCareerTrack: SortOrder
  openLesson: SortOrder
  price: SortOrder
  promocode: SortOrder
  published: SortOrder
  result: SortOrder
  reviews: SortOrder
  students: SortOrder
  subscription: SortOrder
  subscriptionPrice: SortOrder
  tags: SortOrder
  tariffs: SortOrder
  title: SortOrder
  uniId: SortOrder
  uniID: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
  video: SortOrder
  weeks: SortOrder
}

input CoursePageWhereInput {
  AND: [CoursePageWhereInput!]
  applications: ApplicationListRelationFilter
  audience: StringNullableFilter
  authors: UserListRelationFilter
  banner: StringNullableFilter
  batch: StringNullableFilter
  careerTrack: CareerTrackListRelationFilter
  careerTrackUnit: CareerTrackUnitListRelationFilter
  company: CompanyWhereInput
  companyId: StringNullableFilter
  courseType: EnumCourseTypeNullableFilter
  createdAt: DateTimeFilter
  description: StringFilter
  discountPrice: IntNullableFilter
  examQuestion: ExamQuestionWhereInput
  examQuestionId: StringNullableFilter
  id: StringFilter
  image: StringFilter
  lessons: LessonListRelationFilter
  methods: StringNullableFilter
  new_students: UserListRelationFilter
  news: StringNullableFilter
  NOT: [CoursePageWhereInput!]
  numInCareerTrack: IntNullableFilter
  openLesson: StringNullableFilter
  OR: [CoursePageWhereInput!]
  orders: OrderListRelationFilter
  PointA: PointAListRelationFilter
  PointATest: PointATestListRelationFilter
  posts: PostListRelationFilter
  price: IntNullableFilter
  promocode: JsonNullableFilter
  published: BoolNullableFilter
  result: StringNullableFilter
  reviews: JsonNullableFilter
  students: StringNullableListFilter
  subscription: BoolNullableFilter
  subscriptionPrice: IntNullableFilter
  tags: StringNullableListFilter
  tariffs: StringNullableFilter
  title: StringFilter
  uni: UniWhereInput
  uniId: StringNullableFilter
  uniID: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
  video: StringNullableFilter
  visits: CourseVisitListRelationFilter
  weeks: IntNullableFilter
}

input CoursePageWhereUniqueInput {
  id: String
}

"""The first Star Wars episodes released"""
enum CourseType {
  CHALLENGE
  FORMONEY
  PRIVATE
  PUBLIC
  UNI
}

type CourseVisit {
  coursePage: CoursePage!
  coursePageId: String!
  createdAt: DateTime!
  id: String!
  reminders: [DateTime!]!
  student: User!
  studentId: String!
  updatedAt: DateTime!
  visitsNumber: Int
}

input CourseVisitListRelationFilter {
  every: CourseVisitWhereInput
  none: CourseVisitWhereInput
  some: CourseVisitWhereInput
}

input CourseVisitOrderByInput {
  coursePageId: SortOrder
  createdAt: SortOrder
  finish: SortOrder
  id: SortOrder
  reminders: SortOrder
  studentId: SortOrder
  updatedAt: SortOrder
  visitsNumber: SortOrder
}

input CourseVisitWhereInput {
  AND: [CourseVisitWhereInput!]
  coursePage: CoursePageWhereInput
  coursePageId: StringFilter
  createdAt: DateTimeFilter
  finish: DateTimeNullableFilter
  id: StringFilter
  NOT: [CourseVisitWhereInput!]
  OR: [CourseVisitWhereInput!]
  reminders: DateTimeNullableListFilter
  student: UserWhereInput
  studentId: StringFilter
  updatedAt: DateTimeFilter
  visitsNumber: IntNullableFilter
}

input CourseVisitWhereUniqueInput {
  id: String
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableListFilter {
  equals: [DateTime!]
}

type Document {
  clauses(after: ClauseWhereUniqueInput, before: ClauseWhereUniqueInput, first: Int, last: Int): [Clause!]!
  complexity: Int
  createdAt: DateTime!
  documentResults(after: DocumentResultWhereUniqueInput, before: DocumentResultWhereUniqueInput, first: Int, last: Int): [DocumentResult!]!
  id: String!
  lesson: Lesson!
  lessonId: String!
  title: String!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input DocumentListRelationFilter {
  every: DocumentWhereInput
  none: DocumentWhereInput
  some: DocumentWhereInput
}

type DocumentResult {
  answers: [String!]!
  createdAt: DateTime!
  document: Document
  documentId: String
  drafts: [String!]!
  id: String!
  lesson: Lesson
  lessonId: String
  updatedAt: DateTime!
  user: User
  userId: String
}

input DocumentResultListRelationFilter {
  every: DocumentResultWhereInput
  none: DocumentResultWhereInput
  some: DocumentResultWhereInput
}

input DocumentResultWhereInput {
  AND: [DocumentResultWhereInput!]
  answers: StringNullableListFilter
  createdAt: DateTimeFilter
  document: DocumentWhereInput
  documentId: StringNullableFilter
  drafts: StringNullableListFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  NOT: [DocumentResultWhereInput!]
  OR: [DocumentResultWhereInput!]
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringNullableFilter
}

input DocumentResultWhereUniqueInput {
  id: String
}

input DocumentWhereInput {
  AND: [DocumentWhereInput!]
  clauses: ClauseListRelationFilter
  complexity: IntNullableFilter
  createdAt: DateTimeFilter
  documentResults: DocumentResultListRelationFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  NOT: [DocumentWhereInput!]
  OR: [DocumentWhereInput!]
  title: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input DocumentWhereUniqueInput {
  id: String
}

input EnumCourseTypeNullableFilter {
  equals: CourseType
  in: [CourseType!]
  not: NestedEnumCourseTypeNullableFilter
  notIn: [CourseType!]
}

input EnumLevelNullableFilter {
  equals: Level
  in: [Level!]
  not: NestedEnumLevelNullableFilter
  notIn: [Level!]
}

input EnumPermissionNullableListFilter {
  equals: [Permission!]
}

input ExamAnswerListRelationFilter {
  every: ExamAnswerWhereInput
  none: ExamAnswerWhereInput
  some: ExamAnswerWhereInput
}

input ExamAnswerWhereInput {
  AND: [ExamAnswerWhereInput!]
  answer: StringFilter
  createdAt: DateTimeFilter
  examQuestion: ExamQuestionWhereInput
  examQuestionId: StringFilter
  examQuestionID: StringFilter
  id: StringFilter
  legalPortfolio: LegalPortfolioListRelationFilter
  NOT: [ExamAnswerWhereInput!]
  OR: [ExamAnswerWhereInput!]
  studentId: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
}

input ExamListRelationFilter {
  every: ExamWhereInput
  none: ExamWhereInput
  some: ExamWhereInput
}

input ExamQuestionWhereInput {
  AND: [ExamQuestionWhereInput!]
  coursePage: CoursePageWhereInput
  coursePageID: StringFilter
  createdAt: DateTimeFilter
  examAnswer: ExamAnswerListRelationFilter
  id: StringFilter
  NOT: [ExamQuestionWhereInput!]
  OR: [ExamQuestionWhereInput!]
  question: StringFilter
  updatedAt: DateTimeFilter
}

input ExamResultListRelationFilter {
  every: ExamResultWhereInput
  none: ExamResultWhereInput
  some: ExamResultWhereInput
}

input ExamResultWhereInput {
  AND: [ExamResultWhereInput!]
  answers: StringNullableListFilter
  createdAt: DateTimeFilter
  exam: ExamWhereInput
  examId: StringNullableFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  NOT: [ExamResultWhereInput!]
  OR: [ExamResultWhereInput!]
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringNullableFilter
}

input ExamWhereInput {
  AND: [ExamWhereInput!]
  createdAt: DateTimeFilter
  examResult: ExamResultListRelationFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  name: StringNullableFilter
  nodeID: StringNullableFilter
  nodeType: StringNullableFilter
  NOT: [ExamWhereInput!]
  OR: [ExamWhereInput!]
  question: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

type Feedback {
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  lessonId: String
  student: User!
  studentId: String!
  teacher: User!
  teacherId: String!
  text: String!
  updatedAt: DateTime!
}

input FeedbackListRelationFilter {
  every: FeedbackWhereInput
  none: FeedbackWhereInput
  some: FeedbackWhereInput
}

input FeedbackOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  lessonId: SortOrder
  studentId: SortOrder
  teacherId: SortOrder
  text: SortOrder
  updatedAt: SortOrder
}

input FeedbackWhereInput {
  AND: [FeedbackWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  NOT: [FeedbackWhereInput!]
  OR: [FeedbackWhereInput!]
  student: UserWhereInput
  studentId: StringFilter
  teacher: UserWhereInput
  teacherId: StringFilter
  text: StringFilter
  updatedAt: DateTimeFilter
}

input FeedbackWhereUniqueInput {
  id: String
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

type Forum {
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  rating(after: RatingWhereUniqueInput, before: RatingWhereUniqueInput, first: Int, last: Int): [Rating!]!
  statements(after: StatementWhereUniqueInput, before: StatementWhereUniqueInput, first: Int, last: Int): [Statement!]!
  text: String
  updatedAt: DateTime!
  user: User
  userId: String
}

input ForumListRelationFilter {
  every: ForumWhereInput
  none: ForumWhereInput
  some: ForumWhereInput
}

input ForumWhereInput {
  AND: [ForumWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  NOT: [ForumWhereInput!]
  OR: [ForumWhereInput!]
  rating: RatingListRelationFilter
  statements: StatementListRelationFilter
  text: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringNullableFilter
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

input JsonNullableFilter {
  equals: Json
  not: Json
}

input JsonNullableListFilter {
  equals: [Json!]
}

input LegalPortfolioListRelationFilter {
  every: LegalPortfolioWhereInput
  none: LegalPortfolioWhereInput
  some: LegalPortfolioWhereInput
}

input LegalPortfolioWhereInput {
  AND: [LegalPortfolioWhereInput!]
  createdAt: DateTimeFilter
  cv: StringNullableFilter
  examAnswer: ExamAnswerListRelationFilter
  id: StringFilter
  NOT: [LegalPortfolioWhereInput!]
  open: BoolFilter
  OR: [LegalPortfolioWhereInput!]
  portfolioIDs: StringNullableListFilter
  resume: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
}

type Lesson {
  challenge_num: Int
  challengeResults(after: ChallengeResultWhereUniqueInput, before: ChallengeResultWhereUniqueInput, first: Int, last: Int): [ChallengeResult!]!
  change: String
  chats(after: ChatWhereUniqueInput, before: ChatWhereUniqueInput, first: Int, last: Int): [Chat!]!
  constructionResults(after: ConstructionResultWhereUniqueInput, before: ConstructionResultWhereUniqueInput, first: Int, last: Int): [ConstructionResult!]!
  constructions(after: ConstructionWhereUniqueInput, before: ConstructionWhereUniqueInput, first: Int, last: Int): [Construction!]!
  coursePage: CoursePage!
  coursePageId: String!
  coursePageID: String!
  createdAt: DateTime!
  description: String
  documents(after: DocumentWhereUniqueInput, before: DocumentWhereUniqueInput, first: Int, last: Int): [Document!]!
  forum: Forum
  forumId: String
  id: String!
  lessonResults(after: LessonResultWhereUniqueInput, before: LessonResultWhereUniqueInput, first: Int, last: Int): [LessonResult!]!
  map: [Json!]!
  name: String!
  newTests(after: NewTestWhereUniqueInput, before: NewTestWhereUniqueInput, first: Int, last: Int): [NewTest!]!
  notes(after: NoteWhereUniqueInput, before: NoteWhereUniqueInput, first: Int, last: Int): [Note!]!
  number: Int
  open: Boolean
  problemResults(after: ProblemResultWhereUniqueInput, before: ProblemResultWhereUniqueInput, first: Int, last: Int): [ProblemResult!]!
  problems(after: ProblemWhereUniqueInput, before: ProblemWhereUniqueInput, first: Int, last: Int): [Problem!]!
  published: Boolean
  quizes(after: QuizWhereUniqueInput, before: QuizWhereUniqueInput, first: Int, last: Int): [Quiz!]!
  quizResults(after: QuizResultWhereUniqueInput, before: QuizResultWhereUniqueInput, first: Int, last: Int): [QuizResult!]!
  shotResults(after: ShotResultWhereUniqueInput, before: ShotResultWhereUniqueInput, first: Int, last: Int): [ShotResult!]!
  shots(after: ShotWhereUniqueInput, before: ShotWhereUniqueInput, first: Int, last: Int): [Shot!]!
  structure: Json
  testResults(after: TestResultWhereUniqueInput, before: TestResultWhereUniqueInput, first: Int, last: Int): [TestResult!]!
  text: String!
  textEditorResults(after: TextEditorResultWhereUniqueInput, before: TextEditorResultWhereUniqueInput, first: Int, last: Int): [TextEditorResult!]!
  texteditors(after: TextEditorWhereUniqueInput, before: TextEditorWhereUniqueInput, first: Int, last: Int): [TextEditor!]!
  type: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input LessonItem {
  id: String
  type: String
}

input LessonListRelationFilter {
  every: LessonWhereInput
  none: LessonWhereInput
  some: LessonWhereInput
}

type LessonResult {
  createdAt: DateTime!
  id: String!
  lesson: Lesson!
  lessonID: String
  progress: Int
  student: User!
  updatedAt: DateTime!
  visitsNumber: Int
}

input LessonResultListRelationFilter {
  every: LessonResultWhereInput
  none: LessonResultWhereInput
  some: LessonResultWhereInput
}

input LessonResultOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  lessonId: SortOrder
  lessonID: SortOrder
  progress: SortOrder
  studentId: SortOrder
  updatedAt: SortOrder
  visitsNumber: SortOrder
}

input LessonResultWhereInput {
  AND: [LessonResultWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  lessonID: StringNullableFilter
  NOT: [LessonResultWhereInput!]
  OR: [LessonResultWhereInput!]
  progress: IntNullableFilter
  student: UserWhereInput
  studentId: StringFilter
  updatedAt: DateTimeFilter
  visitsNumber: IntNullableFilter
}

input LessonResultWhereUniqueInput {
  id: String
}

input LessonStructure {
  lessonItems: [LessonItem]
}

input LessonWhereInput {
  AND: [LessonWhereInput!]
  challenge_num: IntNullableFilter
  challengeResults: ChallengeResultListRelationFilter
  change: StringNullableFilter
  chats: ChatListRelationFilter
  constructionResults: ConstructionResultListRelationFilter
  constructions: ConstructionListRelationFilter
  coursePage: CoursePageWhereInput
  coursePageId: StringFilter
  coursePageID: StringFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  documentResult: DocumentResultListRelationFilter
  documents: DocumentListRelationFilter
  exam: ExamListRelationFilter
  examResult: ExamResultListRelationFilter
  forum: ForumWhereInput
  forumId: StringNullableFilter
  id: StringFilter
  image: StringNullableFilter
  lessonFeedback: FeedbackListRelationFilter
  lessonResults: LessonResultListRelationFilter
  map: JsonNullableListFilter
  name: StringFilter
  newTests: NewTestListRelationFilter
  NOT: [LessonWhereInput!]
  notes: NoteListRelationFilter
  number: IntNullableFilter
  open: BoolNullableFilter
  OR: [LessonWhereInput!]
  problemResults: ProblemResultListRelationFilter
  problems: ProblemListRelationFilter
  published: BoolNullableFilter
  quizes: QuizListRelationFilter
  quizResults: QuizResultListRelationFilter
  shotResults: ShotResultListRelationFilter
  shots: ShotListRelationFilter
  structure: JsonNullableFilter
  test: TestListRelationFilter
  testResults: TestResultListRelationFilter
  text: StringFilter
  textEditorResults: TextEditorResultListRelationFilter
  texteditors: TextEditorListRelationFilter
  type: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input LessonWhereUniqueInput {
  forumId: String
  id: String
}

enum Level {
  ADVANCED
  STANDARD
}

type Message {
  message: String
}

input MessageElement {
  author: String
  image: String
  number: Int
  text: String
}

input Messages {
  messagesList: [MessageElement]
}

type Mutation {
  createBusinessClient(communication_medium: String, email: String, name: String, number: String, type: String): BusinessClient
  createChallengeResult(correct: Int, lesson: String, time: Int, wrong: Int): ChallengeResult
  createChat(lessonId: String, messages: Messages, name: String): Chat
  createClause(commentary: String, documentId: String, keywords: [String], number: Int, sample: String, title: String): Clause
  createConfUser(conf_number: Int, email: String): ConfUser
  createConstruction(answer: [String], hasText: Boolean, hint: String, lessonId: String, name: String, text: String, type: String, variants: [String]): Construction
  createConstructionResult(answer: String, attempts: Int, constructionId: String, inputs: [String], lessonId: String): ConstructionResult
  createCoursePage(courseType: String, description: String, image: String, published: Boolean, title: String): CoursePage
  createCourseVisit(coursePageId: String, studentId: String, visitsNumber: Int): CourseVisit
  createDocument(lessonId: String, title: String): Document
  createDocumentResult(answers: [String], documentId: String, drafts: [String], lessonId: String): DocumentResult
  createFeedback(lessonId: String, studentId: String, text: String): Feedback
  createForum(lessonId: String, text: String): Forum
  createLesson(coursePageID: String, description: String, name: String, number: Int, text: String): Lesson
  createLessonResult(lessonID: String, visitsNumber: Int): LessonResult
  createNewTest(answers: [String], correct: [Boolean], ifRight: String, ifWrong: String, lessonId: String, question: [String]): NewTest
  createNote(lessonId: String, text: String): Note
  createOrder(comment: String, coursePageId: String, price: Int, promocode: String, userId: String): PaymentInfo
  createPost(text: String, title: String): Post
  createProblem(lessonId: String, nodeID: String, nodeType: String, text: String): Problem
  createProblemResult(answer: String, lessonId: String, problemID: String, revealed: [String]): ProblemResult
  createQuiz(answer: String, ifRight: String, ifWrong: String, lessonId: String, question: String): Quiz
  createQuizResult(answer: String, correct: Boolean, lessonId: String, quiz: String): QuizResult
  createRating(forumId: String, rating: Int): Rating
  createShot(comments: [String], lessonId: String, parts: [String], title: String): Shot
  createShotResult(answer: String, lessonId: String, shotId: String): ShotResult
  createStatement(forumId: String, text: String): Statement
  createTestResult(answer: String, lessonID: String, testID: String): TestResult
  createTextEditor(lessonId: String, name: String, text: String, totalMistakes: Int): TextEditor
  createTextEditorResult(attempts: Int, correct: String, guess: String, lessonId: String, result: Boolean, textEditorId: String, wrong: String): TextEditorResult
  deleteClause(id: String): Clause
  deleteConstruction(id: String): Construction
  deleteDocument(id: String): Document
  deleteLesson(id: String): Lesson
  deleteNewTest(id: String): NewTest
  deleteNote(id: String): Note
  deleteOrder(id: String): Order
  deleteProblem(id: String): Problem
  deleteQuiz(id: String): Quiz
  deleteShot(id: String): Shot
  deleteStatement(id: String): Statement
  deleteTextEditor(id: String): TextEditor
  enrollOnCourse(coursePageId: String, id: String): User
  newWeek(id: String, reminders: [DateTime]): CourseVisit
  remind(id: String, reminders: [DateTime]): CourseVisit
  requestReset(email: String): Message
  resetPassword(confirmPassword: String, password: String, resetToken: String): User
  signin(email: String, password: String): AuthPayload
  signout: SignOut
  signup(careerTrackID: String, company: String, email: String, isFamiliar: Boolean, name: String, password: String, status: Status, surname: String, uniID: String): AuthPayload
  updateChat(id: String, messages: Messages, name: String): Chat
  updateClause(commentary: String, id: String, keywords: [String], number: Int, sample: String, text: String): Clause
  updateConfUser(id: String, name: String, surname: String): ConfUser
  updateConstruction(answer: [String], complexity: Int, hint: String, id: String, name: String, type: String, variants: [String]): Construction
  updateCoursePage(audience: String, authors: String, description: String, id: String, image: String, methods: String, news: String, promocode: PromocodeList, result: String, tariffs: String, title: String, video: String): CoursePage
  updateCourseVisit(id: String, visitsNumber: Int): CourseVisit
  updateForum(id: String, text: String): Forum
  updateLesson(audience: String, challenge_num: Int, change: String, description: String, id: String, name: String, number: Int, open: Boolean, structure: LessonStructure, tariffs: String, text: String, type: String): Lesson
  updateLessonResult(id: String, progress: Int, visitsNumber: Int): LessonResult
  updateNewTest(answers: [String], complexity: Int, correct: [Boolean], id: String, ifRight: String, ifWrong: String, next: NextType, question: [String]): NewTest
  updateNote(complexity: Int, id: String, next: NextType, text: String): Note
  updateOrder(id: String, isPaid: Boolean): Order
  updatePost(id: String, text: String): Post
  updateProblem(complexity: Int, id: String, nodeID: String, nodeType: String, text: String): Problem
  updatePublished(id: String, published: Boolean): Lesson
  updateQuiz(answer: String, check: String, complexity: Int, id: String, ifRight: String, ifWrong: String, lessonId: String, next: NextType, question: String): Quiz
  updateRating(id: String, rating: Int): Rating
  updateShot(comments: [String], id: String, parts: [String], title: String): Shot
  updateStatement(comments: [String], id: String): Statement
  updateTextEditor(complexity: Int, id: String, name: String, text: String, totalMistakes: Int): TextEditor
  updateUser(email: String, id: String, image: String, isFamiliar: Boolean, name: String, status: Status, surname: String): User
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedEnumCourseTypeNullableFilter {
  equals: CourseType
  in: [CourseType!]
  not: NestedEnumCourseTypeNullableFilter
  notIn: [CourseType!]
}

input NestedEnumLevelNullableFilter {
  equals: Level
  in: [Level!]
  not: NestedEnumLevelNullableFilter
  notIn: [Level!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type NewTest {
  answers: [String!]!
  complexity: Int
  correct: [Boolean!]!
  createdAt: DateTime!
  id: String!
  ifRight: String
  ifWrong: String
  lesson: Lesson
  lessonId: String
  lessonID: String
  next: Json
  question: [String!]!
  testResults(after: TestResultWhereUniqueInput, before: TestResultWhereUniqueInput, first: Int, last: Int): [TestResult!]!
  type: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input NewTestListRelationFilter {
  every: NewTestWhereInput
  none: NewTestWhereInput
  some: NewTestWhereInput
}

input NewTestWhereInput {
  AND: [NewTestWhereInput!]
  answers: StringNullableListFilter
  complexity: IntNullableFilter
  correct: BoolNullableListFilter
  createdAt: DateTimeFilter
  id: StringFilter
  ifRight: StringNullableFilter
  ifWrong: StringNullableFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  next: JsonNullableFilter
  NOT: [NewTestWhereInput!]
  OR: [NewTestWhereInput!]
  question: StringNullableListFilter
  testResults: TestResultListRelationFilter
  type: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input NewTestWhereUniqueInput {
  id: String
}

input NextFalseType {
  type: String
  value: String
}

input NextTrueType {
  type: String
  value: String
}

input NextType {
  false: NextFalseType
  true: NextTrueType
}

type Note {
  complexity: Int
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  lessonId: String
  lessonID: String
  next: Json
  text: String!
  updatedAt: DateTime!
  user: User
  userId: String
}

input NoteListRelationFilter {
  every: NoteWhereInput
  none: NoteWhereInput
  some: NoteWhereInput
}

input NoteWhereInput {
  AND: [NoteWhereInput!]
  chat: BoolNullableFilter
  complexity: IntNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  next: JsonNullableFilter
  NOT: [NoteWhereInput!]
  OR: [NoteWhereInput!]
  text: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringNullableFilter
}

input NoteWhereUniqueInput {
  id: String
}

type Order {
  comment: String
  coursePage: CoursePage!
  coursePageId: String!
  createdAt: DateTime!
  id: String!
  isPaid: Boolean
  level: Level
  paymentID: String
  price: Int
  promocode: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input OrderListRelationFilter {
  every: OrderWhereInput
  none: OrderWhereInput
  some: OrderWhereInput
}

input OrderOrderByInput {
  comment: SortOrder
  coursePageId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  isPaid: SortOrder
  level: SortOrder
  paymentID: SortOrder
  price: SortOrder
  promocode: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input OrderWhereInput {
  AND: [OrderWhereInput!]
  comment: StringNullableFilter
  coursePage: CoursePageWhereInput
  coursePageId: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  isPaid: BoolNullableFilter
  level: EnumLevelNullableFilter
  NOT: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  paymentID: StringNullableFilter
  price: IntNullableFilter
  promocode: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input OrderWhereUniqueInput {
  id: String
}

type PaymentInfo {
  order: Order
  url: String
}

"""The first Star Wars episodes released"""
enum Permission {
  ADMIN
  USER
}

input PointAListRelationFilter {
  every: PointAWhereInput
  none: PointAWhereInput
  some: PointAWhereInput
}

input PointATestListRelationFilter {
  every: PointATestWhereInput
  none: PointATestWhereInput
  some: PointATestWhereInput
}

input PointATestWhereInput {
  AND: [PointATestWhereInput!]
  answer1: StringFilter
  answer1Correct: StringFilter
  answer2: StringFilter
  answer2Correct: StringFilter
  answer3: StringNullableFilter
  answer3Correct: StringNullableFilter
  answer4: StringNullableFilter
  answer4Correct: StringNullableFilter
  coursePage: CoursePageWhereInput
  coursePageId: StringNullableFilter
  coursePageID: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [PointATestWhereInput!]
  OR: [PointATestWhereInput!]
  pointA: PointAListRelationFilter
  question: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input PointAWhereInput {
  AND: [PointAWhereInput!]
  coursePage: CoursePageWhereInput
  coursePageId: StringFilter
  coursePageID: StringNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: StringFilter
  NOT: [PointAWhereInput!]
  OR: [PointAWhereInput!]
  pointATest: PointATestListRelationFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

type Post {
  coursePages(after: CoursePageWhereUniqueInput, before: CoursePageWhereUniqueInput, first: Int, last: Int): [CoursePage!]!
  createdAt: DateTime!
  id: String!
  likes: Int
  tags: [String!]!
  text: String
  title: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

input PostOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  likes: SortOrder
  tags: SortOrder
  text: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostWhereInput {
  AND: [PostWhereInput!]
  coursePages: CoursePageListRelationFilter
  createdAt: DateTimeFilter
  id: StringFilter
  likes: IntNullableFilter
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  tags: StringNullableListFilter
  text: StringNullableFilter
  title: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input PostWhereUniqueInput {
  id: String
}

type Problem {
  complexity: Int
  createdAt: DateTime!
  id: String!
  lesson: Lesson!
  lessonId: String!
  lessonID: String!
  nodeID: String
  nodeType: String
  problemResults(after: ProblemResultWhereUniqueInput, before: ProblemResultWhereUniqueInput, first: Int, last: Int): [ProblemResult!]!
  text: String!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input ProblemListRelationFilter {
  every: ProblemWhereInput
  none: ProblemWhereInput
  some: ProblemWhereInput
}

type ProblemResult {
  answer: String
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  lessonId: String
  lessonID: String
  problem: Problem
  problemId: String
  problemID: String
  revealed: [String!]!
  student: User!
  studentId: String!
  updatedAt: DateTime!
}

input ProblemResultListRelationFilter {
  every: ProblemResultWhereInput
  none: ProblemResultWhereInput
  some: ProblemResultWhereInput
}

input ProblemResultOrderByInput {
  answer: SortOrder
  createdAt: SortOrder
  id: SortOrder
  lessonId: SortOrder
  lessonID: SortOrder
  problemId: SortOrder
  problemID: SortOrder
  revealed: SortOrder
  studentId: SortOrder
  updatedAt: SortOrder
}

input ProblemResultWhereInput {
  AND: [ProblemResultWhereInput!]
  answer: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  NOT: [ProblemResultWhereInput!]
  OR: [ProblemResultWhereInput!]
  problem: ProblemWhereInput
  problemId: StringNullableFilter
  problemID: StringNullableFilter
  revealed: StringNullableListFilter
  student: UserWhereInput
  studentId: StringFilter
  updatedAt: DateTimeFilter
}

input ProblemResultWhereUniqueInput {
  id: String
}

input ProblemWhereInput {
  AND: [ProblemWhereInput!]
  answer: StringNullableFilter
  complexity: IntNullableFilter
  createdAt: DateTimeFilter
  hints: StringNullableFilter
  hintsList: StringNullableListFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  lessonID: StringFilter
  nodeID: StringNullableFilter
  nodeType: StringNullableFilter
  NOT: [ProblemWhereInput!]
  OR: [ProblemWhereInput!]
  problemResults: ProblemResultListRelationFilter
  solution: StringNullableFilter
  solutionList: StringNullableListFilter
  text: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input ProblemWhereUniqueInput {
  id: String
}

input Promocode {
  name: String
  value: Float
}

input PromocodeList {
  promocodes: [Promocode]
}

type Query {
  coursePage(where: CoursePageWhereUniqueInput!): CoursePage
  coursePages(after: CoursePageWhereUniqueInput, before: CoursePageWhereUniqueInput, first: Int, last: Int, orderBy: [CoursePageOrderByInput!], where: CoursePageWhereInput): [CoursePage!]!
  courseVisit(where: CourseVisitWhereUniqueInput!): CourseVisit
  courseVisits(after: CourseVisitWhereUniqueInput, before: CourseVisitWhereUniqueInput, first: Int, last: Int, orderBy: [CourseVisitOrderByInput!], where: CourseVisitWhereInput): [CourseVisit!]!
  feedbacks(after: FeedbackWhereUniqueInput, before: FeedbackWhereUniqueInput, first: Int, last: Int, orderBy: [FeedbackOrderByInput!], where: FeedbackWhereInput): [Feedback!]!
  lesson(where: LessonWhereUniqueInput!): Lesson
  lessonResults(after: LessonResultWhereUniqueInput, before: LessonResultWhereUniqueInput, first: Int, last: Int, orderBy: [LessonResultOrderByInput!], where: LessonResultWhereInput): [LessonResult!]!
  lessons(after: LessonWhereUniqueInput, before: LessonWhereUniqueInput, first: Int, last: Int, where: LessonWhereInput): [Lesson!]!
  me: User
  newTest(where: NewTestWhereUniqueInput!): NewTest
  orders(after: OrderWhereUniqueInput, before: OrderWhereUniqueInput, first: Int, last: Int, orderBy: [OrderOrderByInput!], where: OrderWhereInput): [Order!]!
  posts(after: PostWhereUniqueInput, before: PostWhereUniqueInput, first: Int, last: Int, orderBy: [PostOrderByInput!], where: PostWhereInput): [Post!]!
  problemResults(after: ProblemResultWhereUniqueInput, before: ProblemResultWhereUniqueInput, first: Int, last: Int, orderBy: [ProblemResultOrderByInput!], where: ProblemResultWhereInput): [ProblemResult!]!
  quizResult(where: QuizResultWhereUniqueInput!): QuizResult
  quizResults(after: QuizResultWhereUniqueInput, before: QuizResultWhereUniqueInput, first: Int, last: Int, orderBy: [QuizResultOrderByInput!], where: QuizResultWhereInput): [QuizResult!]!
  quizzes(after: QuizWhereUniqueInput, before: QuizWhereUniqueInput, first: Int, last: Int, orderBy: [QuizOrderByInput!], where: QuizWhereInput): [Quiz!]!
  stats(lessonId: String, userId: String): Stats
  testResult(where: TestResultWhereUniqueInput!): TestResult
  testResults(after: TestResultWhereUniqueInput, before: TestResultWhereUniqueInput, first: Int, last: Int, orderBy: [TestResultOrderByInput!], where: TestResultWhereInput): [TestResult!]!
  textEditorResult(where: TextEditorResultWhereUniqueInput!): TextEditorResult
  textEditorResults(after: TextEditorResultWhereUniqueInput, before: TextEditorResultWhereUniqueInput, first: Int, last: Int, orderBy: [TextEditorResultOrderByInput!], where: TextEditorResultWhereInput): [TextEditorResult!]!
  user(where: UserWhereUniqueInput!): User
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int, orderBy: [UserOrderByInput!], where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type Quiz {
  answer: String!
  check: String
  complexity: Int
  createdAt: DateTime!
  id: String!
  ifRight: String
  ifWrong: String
  lesson: Lesson
  lessonId: String
  lessonID: String
  next: Json
  question: String!
  quizResults(after: QuizResultWhereUniqueInput, before: QuizResultWhereUniqueInput, first: Int, last: Int): [QuizResult!]!
  type: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input QuizListRelationFilter {
  every: QuizWhereInput
  none: QuizWhereInput
  some: QuizWhereInput
}

input QuizOrderByInput {
  answer: SortOrder
  check: SortOrder
  complexity: SortOrder
  createdAt: SortOrder
  id: SortOrder
  ifRight: SortOrder
  ifWrong: SortOrder
  lessonId: SortOrder
  lessonID: SortOrder
  next: SortOrder
  question: SortOrder
  type: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type QuizResult {
  answer: String
  attempts: Int
  correct: Boolean
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  lessonId: String
  lessonID: String
  quiz: Quiz
  quizId: String
  student: User!
  studentId: String!
  updatedAt: DateTime!
}

input QuizResultListRelationFilter {
  every: QuizResultWhereInput
  none: QuizResultWhereInput
  some: QuizResultWhereInput
}

input QuizResultOrderByInput {
  answer: SortOrder
  attempts: SortOrder
  correct: SortOrder
  createdAt: SortOrder
  id: SortOrder
  lessonId: SortOrder
  lessonID: SortOrder
  quizId: SortOrder
  studentId: SortOrder
  updatedAt: SortOrder
}

input QuizResultWhereInput {
  AND: [QuizResultWhereInput!]
  answer: StringNullableFilter
  attempts: IntNullableFilter
  correct: BoolNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  NOT: [QuizResultWhereInput!]
  OR: [QuizResultWhereInput!]
  quiz: QuizWhereInput
  quizId: StringNullableFilter
  student: UserWhereInput
  studentId: StringFilter
  updatedAt: DateTimeFilter
}

input QuizResultWhereUniqueInput {
  id: String
}

input QuizWhereInput {
  AND: [QuizWhereInput!]
  answer: StringFilter
  check: StringNullableFilter
  complexity: IntNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  ifRight: StringNullableFilter
  ifWrong: StringNullableFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  next: JsonNullableFilter
  NOT: [QuizWhereInput!]
  OR: [QuizWhereInput!]
  question: StringFilter
  quizResults: QuizResultListRelationFilter
  type: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input QuizWhereUniqueInput {
  id: String
}

type Rating {
  createdAt: DateTime!
  forum: Forum
  forumId: String
  id: String!
  rating: Int
  updatedAt: DateTime!
  user: User
  userId: String
}

input RatingListRelationFilter {
  every: RatingWhereInput
  none: RatingWhereInput
  some: RatingWhereInput
}

input RatingWhereInput {
  AND: [RatingWhereInput!]
  createdAt: DateTimeFilter
  forum: ForumWhereInput
  forumId: StringNullableFilter
  id: StringFilter
  NOT: [RatingWhereInput!]
  OR: [RatingWhereInput!]
  rating: IntNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringNullableFilter
}

input RatingWhereUniqueInput {
  id: String
}

input SandboxListRelationFilter {
  every: SandboxWhereInput
  none: SandboxWhereInput
  some: SandboxWhereInput
}

input SandboxPageGoalListRelationFilter {
  every: SandboxPageGoalWhereInput
  none: SandboxPageGoalWhereInput
  some: SandboxPageGoalWhereInput
}

input SandboxPageGoalWhereInput {
  AND: [SandboxPageGoalWhereInput!]
  completed: BoolFilter
  createdAt: DateTimeFilter
  goal: StringFilter
  id: StringFilter
  NOT: [SandboxPageGoalWhereInput!]
  OR: [SandboxPageGoalWhereInput!]
  sandboxPage: SandboxPageWhereInput
  sandboxPageId: StringNullableFilter
  sandboxPageID: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input SandboxPageListRelationFilter {
  every: SandboxPageWhereInput
  none: SandboxPageWhereInput
  some: SandboxPageWhereInput
}

input SandboxPageWhereInput {
  AND: [SandboxPageWhereInput!]
  createdAt: DateTimeFilter
  description: StringFilter
  id: StringFilter
  image: StringFilter
  NOT: [SandboxPageWhereInput!]
  OR: [SandboxPageWhereInput!]
  sandbox: SandboxListRelationFilter
  sandboxPageGoal: SandboxPageGoalListRelationFilter
  students: StringNullableListFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input SandboxWhereInput {
  AND: [SandboxWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  likes: IntNullableFilter
  link: StringNullableFilter
  NOT: [SandboxWhereInput!]
  OR: [SandboxWhereInput!]
  sandboxPage: SandboxPageWhereInput
  sandboxPageId: StringFilter
  sandboxPageID: StringFilter
  text: StringFilter
  updatedAt: DateTimeFilter
  video: StringNullableFilter
}

type Shot {
  comments: [String!]!
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  lessonId: String
  lessonID: String
  parts: [String!]!
  shotResults(after: ShotResultWhereUniqueInput, before: ShotResultWhereUniqueInput, first: Int, last: Int): [ShotResult!]!
  title: String!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input ShotListRelationFilter {
  every: ShotWhereInput
  none: ShotWhereInput
  some: ShotWhereInput
}

type ShotResult {
  answer: String!
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  lessonId: String
  shot: Shot
  shotId: String
  student: User!
  studentId: String!
  updatedAt: DateTime!
}

input ShotResultListRelationFilter {
  every: ShotResultWhereInput
  none: ShotResultWhereInput
  some: ShotResultWhereInput
}

input ShotResultWhereInput {
  AND: [ShotResultWhereInput!]
  answer: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  NOT: [ShotResultWhereInput!]
  OR: [ShotResultWhereInput!]
  shot: ShotWhereInput
  shotId: StringNullableFilter
  shotID: StringNullableFilter
  student: UserWhereInput
  studentId: StringFilter
  updatedAt: DateTimeFilter
}

input ShotResultWhereUniqueInput {
  id: String
}

input ShotWhereInput {
  AND: [ShotWhereInput!]
  comments: StringNullableListFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  NOT: [ShotWhereInput!]
  OR: [ShotWhereInput!]
  parts: StringNullableListFilter
  shotResults: ShotResultListRelationFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input ShotWhereUniqueInput {
  id: String
}

type SignOut {
  message: String
}

enum SortOrder {
  asc
  desc
}

type Statement {
  comments: [String!]!
  createdAt: DateTime!
  forum: Forum
  forumId: String
  id: String!
  text: String
  updatedAt: DateTime!
  user: User
  userId: String
}

input StatementListRelationFilter {
  every: StatementWhereInput
  none: StatementWhereInput
  some: StatementWhereInput
}

input StatementWhereInput {
  AND: [StatementWhereInput!]
  comments: StringNullableListFilter
  createdAt: DateTimeFilter
  forum: ForumWhereInput
  forumId: StringNullableFilter
  id: StringFilter
  NOT: [StatementWhereInput!]
  OR: [StatementWhereInput!]
  text: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringNullableFilter
}

input StatementWhereUniqueInput {
  id: String
}

type Stats {
  constructionResults: [ConstructionResult]
  documentResults: [DocumentResult]
  feedbacks: [Feedback]
  problemResults: [ProblemResult]
  quizResults: [QuizResult]
  testResults: [TestResult]
  textEditorResults: [TextEditorResult]
}

"""The first Star Wars episodes released"""
enum Status {
  AUTHOR
  HR
  LAWYER
  SAVVY_AUTHOR
  STUDENT
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
}

input TestListRelationFilter {
  every: TestWhereInput
  none: TestWhereInput
  some: TestWhereInput
}

type TestResult {
  answer: String
  attempts: Int
  createdAt: DateTime!
  id: String!
  lesson: Lesson
  lessonId: String
  lessonID: String
  student: User!
  studentId: String!
  test: NewTest
  testId: String
  testID: String
  updatedAt: DateTime!
}

input TestResultListRelationFilter {
  every: TestResultWhereInput
  none: TestResultWhereInput
  some: TestResultWhereInput
}

input TestResultOrderByInput {
  answer: SortOrder
  attempts: SortOrder
  createdAt: SortOrder
  id: SortOrder
  lessonId: SortOrder
  lessonID: SortOrder
  studentId: SortOrder
  testId: SortOrder
  testID: SortOrder
  updatedAt: SortOrder
}

input TestResultWhereInput {
  AND: [TestResultWhereInput!]
  answer: StringNullableFilter
  attempts: IntNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  NOT: [TestResultWhereInput!]
  OR: [TestResultWhereInput!]
  student: UserWhereInput
  studentId: StringFilter
  test: NewTestWhereInput
  testId: StringNullableFilter
  testID: StringNullableFilter
  updatedAt: DateTimeFilter
}

input TestResultWhereUniqueInput {
  id: String
}

input TestWhereInput {
  AND: [TestWhereInput!]
  answer1: StringFilter
  answer1Correct: StringFilter
  answer2: StringFilter
  answer2Correct: StringFilter
  answer3: StringNullableFilter
  answer3Correct: StringNullableFilter
  answer4: StringNullableFilter
  answer4Correct: StringNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  lessonID: StringNullableFilter
  NOT: [TestWhereInput!]
  OR: [TestWhereInput!]
  question: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

type TextEditor {
  complexity: Int
  createdAt: DateTime!
  id: String!
  lesson: Lesson!
  lessonId: String!
  lessonID: String!
  name: String!
  text: String!
  textEditorResults(after: TextEditorResultWhereUniqueInput, before: TextEditorResultWhereUniqueInput, first: Int, last: Int): [TextEditorResult!]!
  totalMistakes: Int
  updatedAt: DateTime!
  user: User!
  userId: String!
}

input TextEditorListRelationFilter {
  every: TextEditorWhereInput
  none: TextEditorWhereInput
  some: TextEditorWhereInput
}

type TextEditorResult {
  attempts: Int
  correct: String!
  createdAt: DateTime!
  guess: String!
  id: String!
  lesson: Lesson
  lessonId: String
  result: Boolean
  student: User!
  studentId: String!
  textEditor: TextEditor
  textEditorId: String
  updatedAt: DateTime!
  wrong: String!
}

input TextEditorResultListRelationFilter {
  every: TextEditorResultWhereInput
  none: TextEditorResultWhereInput
  some: TextEditorResultWhereInput
}

input TextEditorResultOrderByInput {
  attempts: SortOrder
  correct: SortOrder
  createdAt: SortOrder
  guess: SortOrder
  id: SortOrder
  lessonId: SortOrder
  result: SortOrder
  studentId: SortOrder
  textEditorId: SortOrder
  updatedAt: SortOrder
  wrong: SortOrder
}

input TextEditorResultWhereInput {
  AND: [TextEditorResultWhereInput!]
  attempts: IntNullableFilter
  correct: StringFilter
  createdAt: DateTimeFilter
  guess: StringFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringNullableFilter
  NOT: [TextEditorResultWhereInput!]
  OR: [TextEditorResultWhereInput!]
  result: BoolNullableFilter
  student: UserWhereInput
  studentId: StringFilter
  textEditor: TextEditorWhereInput
  textEditorId: StringNullableFilter
  updatedAt: DateTimeFilter
  wrong: StringFilter
}

input TextEditorResultWhereUniqueInput {
  id: String
}

input TextEditorWhereInput {
  AND: [TextEditorWhereInput!]
  complexity: IntNullableFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lesson: LessonWhereInput
  lessonId: StringFilter
  lessonID: StringFilter
  name: StringFilter
  NOT: [TextEditorWhereInput!]
  OR: [TextEditorWhereInput!]
  text: StringFilter
  textEditorResults: TextEditorResultListRelationFilter
  totalMistakes: IntNullableFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input TextEditorWhereUniqueInput {
  id: String
}

type Uni {
  capacity: Int
  id: String!
  paidMonths: Int
  teachers(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
  title: String!
}

input UniWhereInput {
  AND: [UniWhereInput!]
  capacity: IntNullableFilter
  coursePage: CoursePageListRelationFilter
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [UniWhereInput!]
  OR: [UniWhereInput!]
  paidMonths: IntNullableFilter
  teachers: UserListRelationFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

type User {
  company: Company
  coursePages(after: CoursePageWhereUniqueInput, before: CoursePageWhereUniqueInput, first: Int, last: Int, orderBy: [UserCoursePagesOrderByInput!]): [CoursePage!]!
  courseVisits(after: CourseVisitWhereUniqueInput, before: CourseVisitWhereUniqueInput, first: Int, last: Int): [CourseVisit!]!
  description: String
  email: String!
  id: String!
  image: String
  interests: [String!]!
  lessonResults(after: LessonResultWhereUniqueInput, before: LessonResultWhereUniqueInput, first: Int, last: Int): [LessonResult!]!
  lessons(after: LessonWhereUniqueInput, before: LessonWhereUniqueInput, first: Int, last: Int): [Lesson!]!
  level: UserLevel
  name: String!
  new_subjects(after: CoursePageWhereUniqueInput, before: CoursePageWhereUniqueInput, first: Int, last: Int): [CoursePage!]!
  orders(after: OrderWhereUniqueInput, before: OrderWhereUniqueInput, first: Int, last: Int): [Order!]!
  password: String!
  permissions: [Permission!]!
  resume: String
  status: String
  studentFeedback(after: FeedbackWhereUniqueInput, before: FeedbackWhereUniqueInput, first: Int, last: Int): [Feedback!]!
  surname: String
  teacherFeedback(after: FeedbackWhereUniqueInput, before: FeedbackWhereUniqueInput, first: Int, last: Int): [Feedback!]!
  uni: Uni
}

input UserCoursePagesOrderByInput {
  title: SortOrder
}

type UserLevel {
  createdAt: DateTime!
  id: String!
  level: Float
  updatedAt: DateTime!
  user: User
}

input UserLevelWhereInput {
  AND: [UserLevelWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  level: FloatNullableFilter
  NOT: [UserLevelWhereInput!]
  OR: [UserLevelWhereInput!]
  updatedAt: DateTimeFilter
  user: UserWhereInput
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByInput {
  careerTrackId: SortOrder
  careerTrackID: SortOrder
  companyId: SortOrder
  coverLetter: SortOrder
  createdAt: SortOrder
  description: SortOrder
  email: SortOrder
  favourites: SortOrder
  id: SortOrder
  image: SortOrder
  interests: SortOrder
  isFamiliar: SortOrder
  legalPortfolioId: SortOrder
  levelId: SortOrder
  name: SortOrder
  password: SortOrder
  permissions: SortOrder
  resetToken: SortOrder
  resetTokenExpiry: SortOrder
  resume: SortOrder
  status: SortOrder
  subjects: SortOrder
  surname: SortOrder
  uniId: SortOrder
  uniID: SortOrder
  updatedAt: SortOrder
}

input UserWhereInput {
  AND: [UserWhereInput!]
  careerTrack: CareerTrackWhereInput
  careerTrackId: StringNullableFilter
  careerTrackID: StringNullableFilter
  challengeResults: ChallengeResultListRelationFilter
  chats: ChatListRelationFilter
  clauses: ClauseListRelationFilter
  co_coursePages: CoursePageListRelationFilter
  company: CompanyWhereInput
  companyId: StringNullableFilter
  constructionResults: ConstructionResultListRelationFilter
  constructions: ConstructionListRelationFilter
  coursePages: CoursePageListRelationFilter
  courseVisits: CourseVisitListRelationFilter
  coverLetter: StringNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  documentResults: DocumentResultListRelationFilter
  documents: DocumentListRelationFilter
  email: StringFilter
  examAnswers: ExamAnswerListRelationFilter
  examResults: ExamResultListRelationFilter
  exams: ExamListRelationFilter
  favourites: StringNullableListFilter
  forums: ForumListRelationFilter
  id: StringFilter
  image: StringNullableFilter
  interests: StringNullableListFilter
  isFamiliar: BoolFilter
  legalPortfolio: LegalPortfolioWhereInput
  legalPortfolioId: StringNullableFilter
  lessonResults: LessonResultListRelationFilter
  lessons: LessonListRelationFilter
  level: UserLevelWhereInput
  levelId: StringNullableFilter
  name: StringFilter
  new_subjects: CoursePageListRelationFilter
  newTests: NewTestListRelationFilter
  NOT: [UserWhereInput!]
  notes: NoteListRelationFilter
  OR: [UserWhereInput!]
  orders: OrderListRelationFilter
  password: StringFilter
  permissions: EnumPermissionNullableListFilter
  pointAs: PointAListRelationFilter
  pointATests: PointATestListRelationFilter
  posts: PostListRelationFilter
  problemResults: ProblemResultListRelationFilter
  problems: ProblemListRelationFilter
  quizes: QuizListRelationFilter
  quizResults: QuizResultListRelationFilter
  ratings: RatingListRelationFilter
  resetToken: StringNullableFilter
  resetTokenExpiry: FloatNullableFilter
  resume: StringNullableFilter
  sandboxPageGoals: SandboxPageGoalListRelationFilter
  sandboxPages: SandboxPageListRelationFilter
  shotResults: ShotResultListRelationFilter
  shots: ShotListRelationFilter
  statements: StatementListRelationFilter
  status: StringNullableFilter
  studentFeedback: FeedbackListRelationFilter
  subjects: StringNullableListFilter
  surname: StringNullableFilter
  teacherFeedback: FeedbackListRelationFilter
  testResults: TestResultListRelationFilter
  tests: TestListRelationFilter
  textEditorResults: TextEditorResultListRelationFilter
  textEditors: TextEditorListRelationFilter
  uni: UniWhereInput
  uniId: StringNullableFilter
  uniID: StringNullableFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  careerTrackId: String
  email: String
  id: String
  legalPortfolioId: String
  levelId: String
}
