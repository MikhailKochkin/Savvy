// Code generated by Prisma (prisma@1.17.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { GraphQLSchema } from "graphql";
import { IResolvers } from "graphql-tools/dist/Interfaces";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  case: (where?: CaseWhereInput) => Promise<boolean>;
  coursePage: (where?: CoursePageWhereInput) => Promise<boolean>;
  sandbox: (where?: SandboxWhereInput) => Promise<boolean>;
  sandboxPage: (where?: SandboxPageWhereInput) => Promise<boolean>;
  test: (where?: TestWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export interface Fragmentable {
  $fragment<T>(fragment: string | Object): T;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;
  $getAbstractResolvers(filterSchema?: GraphQLSchema | string): IResolvers;

  /**
   * Queries
   */

  case: (where: CaseWhereUniqueInput) => Case;
  cases: (
    args?: {
      where?: CaseWhereInput;
      orderBy?: CaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<CaseNode>>;
  casesConnection: (
    args?: {
      where?: CaseWhereInput;
      orderBy?: CaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CaseConnection;
  coursePage: (where: CoursePageWhereUniqueInput) => CoursePage;
  coursePages: (
    args?: {
      where?: CoursePageWhereInput;
      orderBy?: CoursePageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<CoursePageNode>>;
  coursePagesConnection: (
    args?: {
      where?: CoursePageWhereInput;
      orderBy?: CoursePageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CoursePageConnection;
  sandbox: (where: SandboxWhereUniqueInput) => Sandbox;
  sandboxes: (
    args?: {
      where?: SandboxWhereInput;
      orderBy?: SandboxOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<SandboxNode>>;
  sandboxesConnection: (
    args?: {
      where?: SandboxWhereInput;
      orderBy?: SandboxOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SandboxConnection;
  sandboxPage: (where: SandboxPageWhereUniqueInput) => SandboxPage;
  sandboxPages: (
    args?: {
      where?: SandboxPageWhereInput;
      orderBy?: SandboxPageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<SandboxPageNode>>;
  sandboxPagesConnection: (
    args?: {
      where?: SandboxPageWhereInput;
      orderBy?: SandboxPageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SandboxPageConnection;
  test: (where: TestWhereUniqueInput) => Test;
  tests: (
    args?: {
      where?: TestWhereInput;
      orderBy?: TestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<TestNode>>;
  testsConnection: (
    args?: {
      where?: TestWhereInput;
      orderBy?: TestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TestConnection;
  user: (where: UserWhereUniqueInput) => User;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<UserNode>>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnection;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCase: (data: CaseCreateInput) => Case;
  updateCase: (
    args: { data: CaseUpdateInput; where: CaseWhereUniqueInput }
  ) => Case;
  updateManyCases: (
    args: { data: CaseUpdateInput; where?: CaseWhereInput }
  ) => BatchPayload;
  upsertCase: (
    args: {
      where: CaseWhereUniqueInput;
      create: CaseCreateInput;
      update: CaseUpdateInput;
    }
  ) => Case;
  deleteCase: (where: CaseWhereUniqueInput) => Case;
  deleteManyCases: (where?: CaseWhereInput) => BatchPayload;
  createCoursePage: (data: CoursePageCreateInput) => CoursePage;
  updateCoursePage: (
    args: { data: CoursePageUpdateInput; where: CoursePageWhereUniqueInput }
  ) => CoursePage;
  updateManyCoursePages: (
    args: { data: CoursePageUpdateInput; where?: CoursePageWhereInput }
  ) => BatchPayload;
  upsertCoursePage: (
    args: {
      where: CoursePageWhereUniqueInput;
      create: CoursePageCreateInput;
      update: CoursePageUpdateInput;
    }
  ) => CoursePage;
  deleteCoursePage: (where: CoursePageWhereUniqueInput) => CoursePage;
  deleteManyCoursePages: (where?: CoursePageWhereInput) => BatchPayload;
  createSandbox: (data: SandboxCreateInput) => Sandbox;
  updateSandbox: (
    args: { data: SandboxUpdateInput; where: SandboxWhereUniqueInput }
  ) => Sandbox;
  updateManySandboxes: (
    args: { data: SandboxUpdateInput; where?: SandboxWhereInput }
  ) => BatchPayload;
  upsertSandbox: (
    args: {
      where: SandboxWhereUniqueInput;
      create: SandboxCreateInput;
      update: SandboxUpdateInput;
    }
  ) => Sandbox;
  deleteSandbox: (where: SandboxWhereUniqueInput) => Sandbox;
  deleteManySandboxes: (where?: SandboxWhereInput) => BatchPayload;
  createSandboxPage: (data: SandboxPageCreateInput) => SandboxPage;
  updateSandboxPage: (
    args: { data: SandboxPageUpdateInput; where: SandboxPageWhereUniqueInput }
  ) => SandboxPage;
  updateManySandboxPages: (
    args: { data: SandboxPageUpdateInput; where?: SandboxPageWhereInput }
  ) => BatchPayload;
  upsertSandboxPage: (
    args: {
      where: SandboxPageWhereUniqueInput;
      create: SandboxPageCreateInput;
      update: SandboxPageUpdateInput;
    }
  ) => SandboxPage;
  deleteSandboxPage: (where: SandboxPageWhereUniqueInput) => SandboxPage;
  deleteManySandboxPages: (where?: SandboxPageWhereInput) => BatchPayload;
  createTest: (data: TestCreateInput) => Test;
  updateTest: (
    args: { data: TestUpdateInput; where: TestWhereUniqueInput }
  ) => Test;
  updateManyTests: (
    args: { data: TestUpdateInput; where?: TestWhereInput }
  ) => BatchPayload;
  upsertTest: (
    args: {
      where: TestWhereUniqueInput;
      create: TestCreateInput;
      update: TestUpdateInput;
    }
  ) => Test;
  deleteTest: (where: TestWhereUniqueInput) => Test;
  deleteManyTests: (where?: TestWhereInput) => BatchPayload;
  createUser: (data: UserCreateInput) => User;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => User;
  updateManyUsers: (
    args: { data: UserUpdateInput; where?: UserWhereInput }
  ) => BatchPayload;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => User;
  deleteUser: (where: UserWhereUniqueInput) => User;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayload;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  case: (
    where?: CaseSubscriptionWhereInput
  ) => CaseSubscriptionPayloadSubscription;
  coursePage: (
    where?: CoursePageSubscriptionWhereInput
  ) => CoursePageSubscriptionPayloadSubscription;
  sandbox: (
    where?: SandboxSubscriptionWhereInput
  ) => SandboxSubscriptionPayloadSubscription;
  sandboxPage: (
    where?: SandboxPageSubscriptionWhereInput
  ) => SandboxPageSubscriptionPayloadSubscription;
  test: (
    where?: TestSubscriptionWhereInput
  ) => TestSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CoursePageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "image_ASC"
  | "image_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CaseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "mainText_ASC"
  | "mainText_DESC"
  | "issue_ASC"
  | "issue_DESC"
  | "rule_ASC"
  | "rule_DESC"
  | "analysis_ASC"
  | "analysis_DESC"
  | "conclusion_ASC"
  | "conclusion_DESC"
  | "image_ASC"
  | "image_DESC"
  | "largeImage_ASC"
  | "largeImage_DESC"
  | "price_ASC"
  | "price_DESC"
  | "coursePageID_ASC"
  | "coursePageID_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Permission =
  | "ADMIN"
  | "USER"
  | "CASECREATE"
  | "CASEUPDATE"
  | "CASEDELETE"
  | "PERMISSIONUPDATE";

export type TestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "question_ASC"
  | "question_DESC"
  | "answer1_ASC"
  | "answer1_DESC"
  | "answer1Correct_ASC"
  | "answer1Correct_DESC"
  | "answer2_ASC"
  | "answer2_DESC"
  | "answer2Correct_ASC"
  | "answer2Correct_DESC"
  | "answer3_ASC"
  | "answer3_DESC"
  | "answer3Correct_ASC"
  | "answer3Correct_DESC"
  | "answer4_ASC"
  | "answer4_DESC"
  | "answer4Correct_ASC"
  | "answer4Correct_DESC"
  | "coursePageID_ASC"
  | "coursePageID_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SandboxPageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "image_ASC"
  | "image_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SandboxOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "sandboxPageID_ASC"
  | "sandboxPageID_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "resetToken_ASC"
  | "resetToken_DESC"
  | "resetTokenExpiry_ASC"
  | "resetTokenExpiry_DESC"
  | "isFamiliar_ASC"
  | "isFamiliar_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface CoursePageUpdateWithWhereUniqueWithoutUserInput {
  where: CoursePageWhereUniqueInput;
  data: CoursePageUpdateWithoutUserDataInput;
}

export type CaseWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CaseUpsertWithWhereUniqueWithoutCoursePageInput {
  where: CaseWhereUniqueInput;
  update: CaseUpdateWithoutCoursePageDataInput;
  create: CaseCreateWithoutCoursePageInput;
}

export interface SandboxPageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  user?: UserWhereInput;
  sandboxes_every?: SandboxWhereInput;
  sandboxes_some?: SandboxWhereInput;
  sandboxes_none?: SandboxWhereInput;
  AND?: SandboxPageWhereInput[] | SandboxPageWhereInput;
  OR?: SandboxPageWhereInput[] | SandboxPageWhereInput;
  NOT?: SandboxPageWhereInput[] | SandboxPageWhereInput;
}

export interface TestUpdateManyWithoutCoursePageInput {
  create?:
    | TestCreateWithoutCoursePageInput[]
    | TestCreateWithoutCoursePageInput;
  delete?: TestWhereUniqueInput[] | TestWhereUniqueInput;
  connect?: TestWhereUniqueInput[] | TestWhereUniqueInput;
  disconnect?: TestWhereUniqueInput[] | TestWhereUniqueInput;
  update?:
    | TestUpdateWithWhereUniqueWithoutCoursePageInput[]
    | TestUpdateWithWhereUniqueWithoutCoursePageInput;
  upsert?:
    | TestUpsertWithWhereUniqueWithoutCoursePageInput[]
    | TestUpsertWithWhereUniqueWithoutCoursePageInput;
}

export interface CaseWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  mainText?: String;
  mainText_not?: String;
  mainText_in?: String[] | String;
  mainText_not_in?: String[] | String;
  mainText_lt?: String;
  mainText_lte?: String;
  mainText_gt?: String;
  mainText_gte?: String;
  mainText_contains?: String;
  mainText_not_contains?: String;
  mainText_starts_with?: String;
  mainText_not_starts_with?: String;
  mainText_ends_with?: String;
  mainText_not_ends_with?: String;
  issue?: String;
  issue_not?: String;
  issue_in?: String[] | String;
  issue_not_in?: String[] | String;
  issue_lt?: String;
  issue_lte?: String;
  issue_gt?: String;
  issue_gte?: String;
  issue_contains?: String;
  issue_not_contains?: String;
  issue_starts_with?: String;
  issue_not_starts_with?: String;
  issue_ends_with?: String;
  issue_not_ends_with?: String;
  rule?: String;
  rule_not?: String;
  rule_in?: String[] | String;
  rule_not_in?: String[] | String;
  rule_lt?: String;
  rule_lte?: String;
  rule_gt?: String;
  rule_gte?: String;
  rule_contains?: String;
  rule_not_contains?: String;
  rule_starts_with?: String;
  rule_not_starts_with?: String;
  rule_ends_with?: String;
  rule_not_ends_with?: String;
  analysis?: String;
  analysis_not?: String;
  analysis_in?: String[] | String;
  analysis_not_in?: String[] | String;
  analysis_lt?: String;
  analysis_lte?: String;
  analysis_gt?: String;
  analysis_gte?: String;
  analysis_contains?: String;
  analysis_not_contains?: String;
  analysis_starts_with?: String;
  analysis_not_starts_with?: String;
  analysis_ends_with?: String;
  analysis_not_ends_with?: String;
  conclusion?: String;
  conclusion_not?: String;
  conclusion_in?: String[] | String;
  conclusion_not_in?: String[] | String;
  conclusion_lt?: String;
  conclusion_lte?: String;
  conclusion_gt?: String;
  conclusion_gte?: String;
  conclusion_contains?: String;
  conclusion_not_contains?: String;
  conclusion_starts_with?: String;
  conclusion_not_starts_with?: String;
  conclusion_ends_with?: String;
  conclusion_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  largeImage?: String;
  largeImage_not?: String;
  largeImage_in?: String[] | String;
  largeImage_not_in?: String[] | String;
  largeImage_lt?: String;
  largeImage_lte?: String;
  largeImage_gt?: String;
  largeImage_gte?: String;
  largeImage_contains?: String;
  largeImage_not_contains?: String;
  largeImage_starts_with?: String;
  largeImage_not_starts_with?: String;
  largeImage_ends_with?: String;
  largeImage_not_ends_with?: String;
  price?: Int;
  price_not?: Int;
  price_in?: Int[] | Int;
  price_not_in?: Int[] | Int;
  price_lt?: Int;
  price_lte?: Int;
  price_gt?: Int;
  price_gte?: Int;
  user?: UserWhereInput;
  coursePage?: CoursePageWhereInput;
  coursePageID?: ID_Input;
  coursePageID_not?: ID_Input;
  coursePageID_in?: ID_Input[] | ID_Input;
  coursePageID_not_in?: ID_Input[] | ID_Input;
  coursePageID_lt?: ID_Input;
  coursePageID_lte?: ID_Input;
  coursePageID_gt?: ID_Input;
  coursePageID_gte?: ID_Input;
  coursePageID_contains?: ID_Input;
  coursePageID_not_contains?: ID_Input;
  coursePageID_starts_with?: ID_Input;
  coursePageID_not_starts_with?: ID_Input;
  coursePageID_ends_with?: ID_Input;
  coursePageID_not_ends_with?: ID_Input;
  AND?: CaseWhereInput[] | CaseWhereInput;
  OR?: CaseWhereInput[] | CaseWhereInput;
  NOT?: CaseWhereInput[] | CaseWhereInput;
}

export interface CaseCreateWithoutUserInput {
  title: String;
  description: String;
  mainText?: String;
  issue?: String;
  rule?: String;
  analysis?: String;
  conclusion?: String;
  image?: String;
  largeImage?: String;
  price?: Int;
  coursePage: CoursePageCreateOneWithoutCasesInput;
  coursePageID: ID_Input;
}

export interface UserUpsertWithoutTestsInput {
  update: UserUpdateWithoutTestsDataInput;
  create: UserCreateWithoutTestsInput;
}

export interface CoursePageCreateOneWithoutCasesInput {
  create?: CoursePageCreateWithoutCasesInput;
  connect?: CoursePageWhereUniqueInput;
}

export interface TestUpdateWithWhereUniqueWithoutCoursePageInput {
  where: TestWhereUniqueInput;
  data: TestUpdateWithoutCoursePageDataInput;
}

export interface CoursePageCreateWithoutCasesInput {
  title: String;
  description: String;
  image: String;
  user: UserCreateOneWithoutCoursePagesInput;
  tests?: TestCreateManyWithoutCoursePageInput;
}

export interface CoursePageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  user?: UserWhereInput;
  cases_every?: CaseWhereInput;
  cases_some?: CaseWhereInput;
  cases_none?: CaseWhereInput;
  tests_every?: TestWhereInput;
  tests_some?: TestWhereInput;
  tests_none?: TestWhereInput;
  AND?: CoursePageWhereInput[] | CoursePageWhereInput;
  OR?: CoursePageWhereInput[] | CoursePageWhereInput;
  NOT?: CoursePageWhereInput[] | CoursePageWhereInput;
}

export interface UserCreateOneWithoutCoursePagesInput {
  create?: UserCreateWithoutCoursePagesInput;
  connect?: UserWhereUniqueInput;
}

export interface SandboxPageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SandboxPageWhereInput;
  AND?: SandboxPageSubscriptionWhereInput[] | SandboxPageSubscriptionWhereInput;
  OR?: SandboxPageSubscriptionWhereInput[] | SandboxPageSubscriptionWhereInput;
  NOT?: SandboxPageSubscriptionWhereInput[] | SandboxPageSubscriptionWhereInput;
}

export interface UserCreateWithoutCoursePagesInput {
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions?: UserCreatepermissionsInput;
  sandboxPages?: SandboxPageCreateManyWithoutUserInput;
  cases?: CaseCreateManyWithoutUserInput;
  tests?: TestCreateManyWithoutUserInput;
  isFamiliar?: Boolean;
}

export interface CoursePageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CoursePageWhereInput;
  AND?: CoursePageSubscriptionWhereInput[] | CoursePageSubscriptionWhereInput;
  OR?: CoursePageSubscriptionWhereInput[] | CoursePageSubscriptionWhereInput;
  NOT?: CoursePageSubscriptionWhereInput[] | CoursePageSubscriptionWhereInput;
}

export interface TestCreateManyWithoutUserInput {
  create?: TestCreateWithoutUserInput[] | TestCreateWithoutUserInput;
  connect?: TestWhereUniqueInput[] | TestWhereUniqueInput;
}

export interface UserUpdateInput {
  name?: String;
  email?: String;
  password?: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions?: UserUpdatepermissionsInput;
  coursePages?: CoursePageUpdateManyWithoutUserInput;
  sandboxPages?: SandboxPageUpdateManyWithoutUserInput;
  cases?: CaseUpdateManyWithoutUserInput;
  tests?: TestUpdateManyWithoutUserInput;
  isFamiliar?: Boolean;
}

export interface TestCreateWithoutUserInput {
  question: String;
  answer1: String;
  answer1Correct: String;
  answer2: String;
  answer2Correct: String;
  answer3?: String;
  answer3Correct?: String;
  answer4?: String;
  answer4Correct?: String;
  coursePage: CoursePageCreateOneWithoutTestsInput;
  coursePageID: ID_Input;
}

export interface TestCreateInput {
  question: String;
  answer1: String;
  answer1Correct: String;
  answer2: String;
  answer2Correct: String;
  answer3?: String;
  answer3Correct?: String;
  answer4?: String;
  answer4Correct?: String;
  user: UserCreateOneWithoutTestsInput;
  coursePage: CoursePageCreateOneWithoutTestsInput;
  coursePageID: ID_Input;
}

export interface CoursePageCreateOneWithoutTestsInput {
  create?: CoursePageCreateWithoutTestsInput;
  connect?: CoursePageWhereUniqueInput;
}

export interface SandboxPageCreateInput {
  title: String;
  description: String;
  image: String;
  user: UserCreateOneWithoutSandboxPagesInput;
  sandboxes?: SandboxCreateManyWithoutSandboxPageInput;
}

export interface CoursePageCreateWithoutTestsInput {
  title: String;
  description: String;
  image: String;
  user: UserCreateOneWithoutCoursePagesInput;
  cases?: CaseCreateManyWithoutCoursePageInput;
}

export interface SandboxPageUpsertWithoutSandboxesInput {
  update: SandboxPageUpdateWithoutSandboxesDataInput;
  create: SandboxPageCreateWithoutSandboxesInput;
}

export interface CaseUpdateInput {
  title?: String;
  description?: String;
  mainText?: String;
  issue?: String;
  rule?: String;
  analysis?: String;
  conclusion?: String;
  image?: String;
  largeImage?: String;
  price?: Int;
  user?: UserUpdateOneRequiredWithoutCasesInput;
  coursePage?: CoursePageUpdateOneRequiredWithoutCasesInput;
  coursePageID?: ID_Input;
}

export interface UserUpdateWithoutSandboxPagesDataInput {
  name?: String;
  email?: String;
  password?: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions?: UserUpdatepermissionsInput;
  coursePages?: CoursePageUpdateManyWithoutUserInput;
  cases?: CaseUpdateManyWithoutUserInput;
  tests?: TestUpdateManyWithoutUserInput;
  isFamiliar?: Boolean;
}

export interface UserUpdateOneRequiredWithoutCasesInput {
  create?: UserCreateWithoutCasesInput;
  update?: UserUpdateWithoutCasesDataInput;
  upsert?: UserUpsertWithoutCasesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutSandboxPagesInput {
  create?: UserCreateWithoutSandboxPagesInput;
  update?: UserUpdateWithoutSandboxPagesDataInput;
  upsert?: UserUpsertWithoutSandboxPagesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutCasesDataInput {
  name?: String;
  email?: String;
  password?: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions?: UserUpdatepermissionsInput;
  coursePages?: CoursePageUpdateManyWithoutUserInput;
  sandboxPages?: SandboxPageUpdateManyWithoutUserInput;
  tests?: TestUpdateManyWithoutUserInput;
  isFamiliar?: Boolean;
}

export interface SandboxPageUpdateOneRequiredWithoutSandboxesInput {
  create?: SandboxPageCreateWithoutSandboxesInput;
  update?: SandboxPageUpdateWithoutSandboxesDataInput;
  upsert?: SandboxPageUpsertWithoutSandboxesInput;
  connect?: SandboxPageWhereUniqueInput;
}

export interface UserUpdatepermissionsInput {
  set?: Permission[] | Permission;
}

export interface SandboxUpdateInput {
  text?: String;
  user?: UserUpdateOneRequiredInput;
  sandboxPage?: SandboxPageUpdateOneRequiredWithoutSandboxesInput;
  sandboxPageID?: ID_Input;
}

export interface CoursePageUpdateManyWithoutUserInput {
  create?:
    | CoursePageCreateWithoutUserInput[]
    | CoursePageCreateWithoutUserInput;
  delete?: CoursePageWhereUniqueInput[] | CoursePageWhereUniqueInput;
  connect?: CoursePageWhereUniqueInput[] | CoursePageWhereUniqueInput;
  disconnect?: CoursePageWhereUniqueInput[] | CoursePageWhereUniqueInput;
  update?:
    | CoursePageUpdateWithWhereUniqueWithoutUserInput[]
    | CoursePageUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | CoursePageUpsertWithWhereUniqueWithoutUserInput[]
    | CoursePageUpsertWithWhereUniqueWithoutUserInput;
}

export interface UserCreateOneWithoutSandboxPagesInput {
  create?: UserCreateWithoutSandboxPagesInput;
  connect?: UserWhereUniqueInput;
}

export interface TestUpsertWithWhereUniqueWithoutCoursePageInput {
  where: TestWhereUniqueInput;
  update: TestUpdateWithoutCoursePageDataInput;
  create: TestCreateWithoutCoursePageInput;
}

export interface SandboxPageCreateWithoutSandboxesInput {
  title: String;
  description: String;
  image: String;
  user: UserCreateOneWithoutSandboxPagesInput;
}

export interface CoursePageUpdateWithoutUserDataInput {
  title?: String;
  description?: String;
  image?: String;
  cases?: CaseUpdateManyWithoutCoursePageInput;
  tests?: TestUpdateManyWithoutCoursePageInput;
}

export interface SandboxCreateInput {
  text: String;
  user: UserCreateOneInput;
  sandboxPage: SandboxPageCreateOneWithoutSandboxesInput;
  sandboxPageID: ID_Input;
}

export interface CaseUpdateManyWithoutCoursePageInput {
  create?:
    | CaseCreateWithoutCoursePageInput[]
    | CaseCreateWithoutCoursePageInput;
  delete?: CaseWhereUniqueInput[] | CaseWhereUniqueInput;
  connect?: CaseWhereUniqueInput[] | CaseWhereUniqueInput;
  disconnect?: CaseWhereUniqueInput[] | CaseWhereUniqueInput;
  update?:
    | CaseUpdateWithWhereUniqueWithoutCoursePageInput[]
    | CaseUpdateWithWhereUniqueWithoutCoursePageInput;
  upsert?:
    | CaseUpsertWithWhereUniqueWithoutCoursePageInput[]
    | CaseUpsertWithWhereUniqueWithoutCoursePageInput;
}

export interface CoursePageUpdateInput {
  title?: String;
  description?: String;
  image?: String;
  user?: UserUpdateOneRequiredWithoutCoursePagesInput;
  cases?: CaseUpdateManyWithoutCoursePageInput;
  tests?: TestUpdateManyWithoutCoursePageInput;
}

export interface CaseUpdateWithWhereUniqueWithoutCoursePageInput {
  where: CaseWhereUniqueInput;
  data: CaseUpdateWithoutCoursePageDataInput;
}

export interface UserUpsertWithoutCasesInput {
  update: UserUpdateWithoutCasesDataInput;
  create: UserCreateWithoutCasesInput;
}

export interface CaseUpdateWithoutCoursePageDataInput {
  title?: String;
  description?: String;
  mainText?: String;
  issue?: String;
  rule?: String;
  analysis?: String;
  conclusion?: String;
  image?: String;
  largeImage?: String;
  price?: Int;
  user?: UserUpdateOneRequiredWithoutCasesInput;
  coursePageID?: ID_Input;
}

export interface UserCreateOneWithoutCasesInput {
  create?: UserCreateWithoutCasesInput;
  connect?: UserWhereUniqueInput;
}

export interface SandboxWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  user?: UserWhereInput;
  sandboxPage?: SandboxPageWhereInput;
  sandboxPageID?: ID_Input;
  sandboxPageID_not?: ID_Input;
  sandboxPageID_in?: ID_Input[] | ID_Input;
  sandboxPageID_not_in?: ID_Input[] | ID_Input;
  sandboxPageID_lt?: ID_Input;
  sandboxPageID_lte?: ID_Input;
  sandboxPageID_gt?: ID_Input;
  sandboxPageID_gte?: ID_Input;
  sandboxPageID_contains?: ID_Input;
  sandboxPageID_not_contains?: ID_Input;
  sandboxPageID_starts_with?: ID_Input;
  sandboxPageID_not_starts_with?: ID_Input;
  sandboxPageID_ends_with?: ID_Input;
  sandboxPageID_not_ends_with?: ID_Input;
  AND?: SandboxWhereInput[] | SandboxWhereInput;
  OR?: SandboxWhereInput[] | SandboxWhereInput;
  NOT?: SandboxWhereInput[] | SandboxWhereInput;
}

export interface UserCreatepermissionsInput {
  set?: Permission[] | Permission;
}

export interface TestWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  question?: String;
  question_not?: String;
  question_in?: String[] | String;
  question_not_in?: String[] | String;
  question_lt?: String;
  question_lte?: String;
  question_gt?: String;
  question_gte?: String;
  question_contains?: String;
  question_not_contains?: String;
  question_starts_with?: String;
  question_not_starts_with?: String;
  question_ends_with?: String;
  question_not_ends_with?: String;
  answer1?: String;
  answer1_not?: String;
  answer1_in?: String[] | String;
  answer1_not_in?: String[] | String;
  answer1_lt?: String;
  answer1_lte?: String;
  answer1_gt?: String;
  answer1_gte?: String;
  answer1_contains?: String;
  answer1_not_contains?: String;
  answer1_starts_with?: String;
  answer1_not_starts_with?: String;
  answer1_ends_with?: String;
  answer1_not_ends_with?: String;
  answer1Correct?: String;
  answer1Correct_not?: String;
  answer1Correct_in?: String[] | String;
  answer1Correct_not_in?: String[] | String;
  answer1Correct_lt?: String;
  answer1Correct_lte?: String;
  answer1Correct_gt?: String;
  answer1Correct_gte?: String;
  answer1Correct_contains?: String;
  answer1Correct_not_contains?: String;
  answer1Correct_starts_with?: String;
  answer1Correct_not_starts_with?: String;
  answer1Correct_ends_with?: String;
  answer1Correct_not_ends_with?: String;
  answer2?: String;
  answer2_not?: String;
  answer2_in?: String[] | String;
  answer2_not_in?: String[] | String;
  answer2_lt?: String;
  answer2_lte?: String;
  answer2_gt?: String;
  answer2_gte?: String;
  answer2_contains?: String;
  answer2_not_contains?: String;
  answer2_starts_with?: String;
  answer2_not_starts_with?: String;
  answer2_ends_with?: String;
  answer2_not_ends_with?: String;
  answer2Correct?: String;
  answer2Correct_not?: String;
  answer2Correct_in?: String[] | String;
  answer2Correct_not_in?: String[] | String;
  answer2Correct_lt?: String;
  answer2Correct_lte?: String;
  answer2Correct_gt?: String;
  answer2Correct_gte?: String;
  answer2Correct_contains?: String;
  answer2Correct_not_contains?: String;
  answer2Correct_starts_with?: String;
  answer2Correct_not_starts_with?: String;
  answer2Correct_ends_with?: String;
  answer2Correct_not_ends_with?: String;
  answer3?: String;
  answer3_not?: String;
  answer3_in?: String[] | String;
  answer3_not_in?: String[] | String;
  answer3_lt?: String;
  answer3_lte?: String;
  answer3_gt?: String;
  answer3_gte?: String;
  answer3_contains?: String;
  answer3_not_contains?: String;
  answer3_starts_with?: String;
  answer3_not_starts_with?: String;
  answer3_ends_with?: String;
  answer3_not_ends_with?: String;
  answer3Correct?: String;
  answer3Correct_not?: String;
  answer3Correct_in?: String[] | String;
  answer3Correct_not_in?: String[] | String;
  answer3Correct_lt?: String;
  answer3Correct_lte?: String;
  answer3Correct_gt?: String;
  answer3Correct_gte?: String;
  answer3Correct_contains?: String;
  answer3Correct_not_contains?: String;
  answer3Correct_starts_with?: String;
  answer3Correct_not_starts_with?: String;
  answer3Correct_ends_with?: String;
  answer3Correct_not_ends_with?: String;
  answer4?: String;
  answer4_not?: String;
  answer4_in?: String[] | String;
  answer4_not_in?: String[] | String;
  answer4_lt?: String;
  answer4_lte?: String;
  answer4_gt?: String;
  answer4_gte?: String;
  answer4_contains?: String;
  answer4_not_contains?: String;
  answer4_starts_with?: String;
  answer4_not_starts_with?: String;
  answer4_ends_with?: String;
  answer4_not_ends_with?: String;
  answer4Correct?: String;
  answer4Correct_not?: String;
  answer4Correct_in?: String[] | String;
  answer4Correct_not_in?: String[] | String;
  answer4Correct_lt?: String;
  answer4Correct_lte?: String;
  answer4Correct_gt?: String;
  answer4Correct_gte?: String;
  answer4Correct_contains?: String;
  answer4Correct_not_contains?: String;
  answer4Correct_starts_with?: String;
  answer4Correct_not_starts_with?: String;
  answer4Correct_ends_with?: String;
  answer4Correct_not_ends_with?: String;
  user?: UserWhereInput;
  coursePage?: CoursePageWhereInput;
  coursePageID?: ID_Input;
  coursePageID_not?: ID_Input;
  coursePageID_in?: ID_Input[] | ID_Input;
  coursePageID_not_in?: ID_Input[] | ID_Input;
  coursePageID_lt?: ID_Input;
  coursePageID_lte?: ID_Input;
  coursePageID_gt?: ID_Input;
  coursePageID_gte?: ID_Input;
  coursePageID_contains?: ID_Input;
  coursePageID_not_contains?: ID_Input;
  coursePageID_starts_with?: ID_Input;
  coursePageID_not_starts_with?: ID_Input;
  coursePageID_ends_with?: ID_Input;
  coursePageID_not_ends_with?: ID_Input;
  AND?: TestWhereInput[] | TestWhereInput;
  OR?: TestWhereInput[] | TestWhereInput;
  NOT?: TestWhereInput[] | TestWhereInput;
}

export interface CoursePageCreateWithoutUserInput {
  title: String;
  description: String;
  image: String;
  cases?: CaseCreateManyWithoutCoursePageInput;
  tests?: TestCreateManyWithoutCoursePageInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  resetToken?: String;
  resetToken_not?: String;
  resetToken_in?: String[] | String;
  resetToken_not_in?: String[] | String;
  resetToken_lt?: String;
  resetToken_lte?: String;
  resetToken_gt?: String;
  resetToken_gte?: String;
  resetToken_contains?: String;
  resetToken_not_contains?: String;
  resetToken_starts_with?: String;
  resetToken_not_starts_with?: String;
  resetToken_ends_with?: String;
  resetToken_not_ends_with?: String;
  resetTokenExpiry?: Float;
  resetTokenExpiry_not?: Float;
  resetTokenExpiry_in?: Float[] | Float;
  resetTokenExpiry_not_in?: Float[] | Float;
  resetTokenExpiry_lt?: Float;
  resetTokenExpiry_lte?: Float;
  resetTokenExpiry_gt?: Float;
  resetTokenExpiry_gte?: Float;
  coursePages_every?: CoursePageWhereInput;
  coursePages_some?: CoursePageWhereInput;
  coursePages_none?: CoursePageWhereInput;
  sandboxPages_every?: SandboxPageWhereInput;
  sandboxPages_some?: SandboxPageWhereInput;
  sandboxPages_none?: SandboxPageWhereInput;
  cases_every?: CaseWhereInput;
  cases_some?: CaseWhereInput;
  cases_none?: CaseWhereInput;
  tests_every?: TestWhereInput;
  tests_some?: TestWhereInput;
  tests_none?: TestWhereInput;
  isFamiliar?: Boolean;
  isFamiliar_not?: Boolean;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface CaseCreateWithoutCoursePageInput {
  title: String;
  description: String;
  mainText?: String;
  issue?: String;
  rule?: String;
  analysis?: String;
  conclusion?: String;
  image?: String;
  largeImage?: String;
  price?: Int;
  user: UserCreateOneWithoutCasesInput;
  coursePageID: ID_Input;
}

export interface TestUpdateWithoutCoursePageDataInput {
  question?: String;
  answer1?: String;
  answer1Correct?: String;
  answer2?: String;
  answer2Correct?: String;
  answer3?: String;
  answer3Correct?: String;
  answer4?: String;
  answer4Correct?: String;
  user?: UserUpdateOneRequiredWithoutTestsInput;
  coursePageID?: ID_Input;
}

export interface TestCreateWithoutCoursePageInput {
  question: String;
  answer1: String;
  answer1Correct: String;
  answer2: String;
  answer2Correct: String;
  answer3?: String;
  answer3Correct?: String;
  answer4?: String;
  answer4Correct?: String;
  user: UserCreateOneWithoutTestsInput;
  coursePageID: ID_Input;
}

export interface UserUpdateOneRequiredWithoutTestsInput {
  create?: UserCreateWithoutTestsInput;
  update?: UserUpdateWithoutTestsDataInput;
  upsert?: UserUpsertWithoutTestsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutTestsInput {
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions?: UserCreatepermissionsInput;
  coursePages?: CoursePageCreateManyWithoutUserInput;
  sandboxPages?: SandboxPageCreateManyWithoutUserInput;
  cases?: CaseCreateManyWithoutUserInput;
  isFamiliar?: Boolean;
}

export interface UserUpdateWithoutTestsDataInput {
  name?: String;
  email?: String;
  password?: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions?: UserUpdatepermissionsInput;
  coursePages?: CoursePageUpdateManyWithoutUserInput;
  sandboxPages?: SandboxPageUpdateManyWithoutUserInput;
  cases?: CaseUpdateManyWithoutUserInput;
  isFamiliar?: Boolean;
}

export interface SandboxPageCreateWithoutUserInput {
  title: String;
  description: String;
  image: String;
  sandboxes?: SandboxCreateManyWithoutSandboxPageInput;
}

export interface SandboxPageUpdateManyWithoutUserInput {
  create?:
    | SandboxPageCreateWithoutUserInput[]
    | SandboxPageCreateWithoutUserInput;
  delete?: SandboxPageWhereUniqueInput[] | SandboxPageWhereUniqueInput;
  connect?: SandboxPageWhereUniqueInput[] | SandboxPageWhereUniqueInput;
  disconnect?: SandboxPageWhereUniqueInput[] | SandboxPageWhereUniqueInput;
  update?:
    | SandboxPageUpdateWithWhereUniqueWithoutUserInput[]
    | SandboxPageUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | SandboxPageUpsertWithWhereUniqueWithoutUserInput[]
    | SandboxPageUpsertWithWhereUniqueWithoutUserInput;
}

export interface SandboxCreateWithoutSandboxPageInput {
  text: String;
  user: UserCreateOneInput;
  sandboxPageID: ID_Input;
}

export interface SandboxPageUpdateWithWhereUniqueWithoutUserInput {
  where: SandboxPageWhereUniqueInput;
  data: SandboxPageUpdateWithoutUserDataInput;
}

export interface UserCreateInput {
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions?: UserCreatepermissionsInput;
  coursePages?: CoursePageCreateManyWithoutUserInput;
  sandboxPages?: SandboxPageCreateManyWithoutUserInput;
  cases?: CaseCreateManyWithoutUserInput;
  tests?: TestCreateManyWithoutUserInput;
  isFamiliar?: Boolean;
}

export interface SandboxPageUpdateWithoutUserDataInput {
  title?: String;
  description?: String;
  image?: String;
  sandboxes?: SandboxUpdateManyWithoutSandboxPageInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface SandboxUpdateManyWithoutSandboxPageInput {
  create?:
    | SandboxCreateWithoutSandboxPageInput[]
    | SandboxCreateWithoutSandboxPageInput;
  delete?: SandboxWhereUniqueInput[] | SandboxWhereUniqueInput;
  connect?: SandboxWhereUniqueInput[] | SandboxWhereUniqueInput;
  disconnect?: SandboxWhereUniqueInput[] | SandboxWhereUniqueInput;
  update?:
    | SandboxUpdateWithWhereUniqueWithoutSandboxPageInput[]
    | SandboxUpdateWithWhereUniqueWithoutSandboxPageInput;
  upsert?:
    | SandboxUpsertWithWhereUniqueWithoutSandboxPageInput[]
    | SandboxUpsertWithWhereUniqueWithoutSandboxPageInput;
}

export interface SandboxSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SandboxWhereInput;
  AND?: SandboxSubscriptionWhereInput[] | SandboxSubscriptionWhereInput;
  OR?: SandboxSubscriptionWhereInput[] | SandboxSubscriptionWhereInput;
  NOT?: SandboxSubscriptionWhereInput[] | SandboxSubscriptionWhereInput;
}

export interface SandboxUpdateWithWhereUniqueWithoutSandboxPageInput {
  where: SandboxWhereUniqueInput;
  data: SandboxUpdateWithoutSandboxPageDataInput;
}

export interface TestUpdateInput {
  question?: String;
  answer1?: String;
  answer1Correct?: String;
  answer2?: String;
  answer2Correct?: String;
  answer3?: String;
  answer3Correct?: String;
  answer4?: String;
  answer4Correct?: String;
  user?: UserUpdateOneRequiredWithoutTestsInput;
  coursePage?: CoursePageUpdateOneRequiredWithoutTestsInput;
  coursePageID?: ID_Input;
}

export interface SandboxUpdateWithoutSandboxPageDataInput {
  text?: String;
  user?: UserUpdateOneRequiredInput;
  sandboxPageID?: ID_Input;
}

export type CoursePageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export type SandboxWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateDataInput {
  name?: String;
  email?: String;
  password?: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions?: UserUpdatepermissionsInput;
  coursePages?: CoursePageUpdateManyWithoutUserInput;
  sandboxPages?: SandboxPageUpdateManyWithoutUserInput;
  cases?: CaseUpdateManyWithoutUserInput;
  tests?: TestUpdateManyWithoutUserInput;
  isFamiliar?: Boolean;
}

export type SandboxPageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CaseUpdateManyWithoutUserInput {
  create?: CaseCreateWithoutUserInput[] | CaseCreateWithoutUserInput;
  delete?: CaseWhereUniqueInput[] | CaseWhereUniqueInput;
  connect?: CaseWhereUniqueInput[] | CaseWhereUniqueInput;
  disconnect?: CaseWhereUniqueInput[] | CaseWhereUniqueInput;
  update?:
    | CaseUpdateWithWhereUniqueWithoutUserInput[]
    | CaseUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | CaseUpsertWithWhereUniqueWithoutUserInput[]
    | CaseUpsertWithWhereUniqueWithoutUserInput;
}

export type TestWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CaseUpdateWithWhereUniqueWithoutUserInput {
  where: CaseWhereUniqueInput;
  data: CaseUpdateWithoutUserDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface CaseUpdateWithoutUserDataInput {
  title?: String;
  description?: String;
  mainText?: String;
  issue?: String;
  rule?: String;
  analysis?: String;
  conclusion?: String;
  image?: String;
  largeImage?: String;
  price?: Int;
  coursePage?: CoursePageUpdateOneRequiredWithoutCasesInput;
  coursePageID?: ID_Input;
}

export interface CoursePageUpsertWithWhereUniqueWithoutUserInput {
  where: CoursePageWhereUniqueInput;
  update: CoursePageUpdateWithoutUserDataInput;
  create: CoursePageCreateWithoutUserInput;
}

export interface CoursePageUpdateOneRequiredWithoutCasesInput {
  create?: CoursePageCreateWithoutCasesInput;
  update?: CoursePageUpdateWithoutCasesDataInput;
  upsert?: CoursePageUpsertWithoutCasesInput;
  connect?: CoursePageWhereUniqueInput;
}

export interface UserCreateWithoutCasesInput {
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions?: UserCreatepermissionsInput;
  coursePages?: CoursePageCreateManyWithoutUserInput;
  sandboxPages?: SandboxPageCreateManyWithoutUserInput;
  tests?: TestCreateManyWithoutUserInput;
  isFamiliar?: Boolean;
}

export interface CoursePageUpdateWithoutCasesDataInput {
  title?: String;
  description?: String;
  image?: String;
  user?: UserUpdateOneRequiredWithoutCoursePagesInput;
  tests?: TestUpdateManyWithoutCoursePageInput;
}

export interface CaseCreateManyWithoutCoursePageInput {
  create?:
    | CaseCreateWithoutCoursePageInput[]
    | CaseCreateWithoutCoursePageInput;
  connect?: CaseWhereUniqueInput[] | CaseWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutCoursePagesInput {
  create?: UserCreateWithoutCoursePagesInput;
  update?: UserUpdateWithoutCoursePagesDataInput;
  upsert?: UserUpsertWithoutCoursePagesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateOneWithoutTestsInput {
  create?: UserCreateWithoutTestsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutCoursePagesDataInput {
  name?: String;
  email?: String;
  password?: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions?: UserUpdatepermissionsInput;
  sandboxPages?: SandboxPageUpdateManyWithoutUserInput;
  cases?: CaseUpdateManyWithoutUserInput;
  tests?: TestUpdateManyWithoutUserInput;
  isFamiliar?: Boolean;
}

export interface SandboxCreateManyWithoutSandboxPageInput {
  create?:
    | SandboxCreateWithoutSandboxPageInput[]
    | SandboxCreateWithoutSandboxPageInput;
  connect?: SandboxWhereUniqueInput[] | SandboxWhereUniqueInput;
}

export interface TestUpdateManyWithoutUserInput {
  create?: TestCreateWithoutUserInput[] | TestCreateWithoutUserInput;
  delete?: TestWhereUniqueInput[] | TestWhereUniqueInput;
  connect?: TestWhereUniqueInput[] | TestWhereUniqueInput;
  disconnect?: TestWhereUniqueInput[] | TestWhereUniqueInput;
  update?:
    | TestUpdateWithWhereUniqueWithoutUserInput[]
    | TestUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | TestUpsertWithWhereUniqueWithoutUserInput[]
    | TestUpsertWithWhereUniqueWithoutUserInput;
}

export interface CaseCreateManyWithoutUserInput {
  create?: CaseCreateWithoutUserInput[] | CaseCreateWithoutUserInput;
  connect?: CaseWhereUniqueInput[] | CaseWhereUniqueInput;
}

export interface TestUpdateWithWhereUniqueWithoutUserInput {
  where: TestWhereUniqueInput;
  data: TestUpdateWithoutUserDataInput;
}

export interface CaseSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CaseWhereInput;
  AND?: CaseSubscriptionWhereInput[] | CaseSubscriptionWhereInput;
  OR?: CaseSubscriptionWhereInput[] | CaseSubscriptionWhereInput;
  NOT?: CaseSubscriptionWhereInput[] | CaseSubscriptionWhereInput;
}

export interface TestUpdateWithoutUserDataInput {
  question?: String;
  answer1?: String;
  answer1Correct?: String;
  answer2?: String;
  answer2Correct?: String;
  answer3?: String;
  answer3Correct?: String;
  answer4?: String;
  answer4Correct?: String;
  coursePage?: CoursePageUpdateOneRequiredWithoutTestsInput;
  coursePageID?: ID_Input;
}

export interface UserUpsertWithoutSandboxPagesInput {
  update: UserUpdateWithoutSandboxPagesDataInput;
  create: UserCreateWithoutSandboxPagesInput;
}

export interface CoursePageUpdateOneRequiredWithoutTestsInput {
  create?: CoursePageCreateWithoutTestsInput;
  update?: CoursePageUpdateWithoutTestsDataInput;
  upsert?: CoursePageUpsertWithoutTestsInput;
  connect?: CoursePageWhereUniqueInput;
}

export interface UserCreateWithoutSandboxPagesInput {
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions?: UserCreatepermissionsInput;
  coursePages?: CoursePageCreateManyWithoutUserInput;
  cases?: CaseCreateManyWithoutUserInput;
  tests?: TestCreateManyWithoutUserInput;
  isFamiliar?: Boolean;
}

export interface CoursePageUpdateWithoutTestsDataInput {
  title?: String;
  description?: String;
  image?: String;
  user?: UserUpdateOneRequiredWithoutCoursePagesInput;
  cases?: CaseUpdateManyWithoutCoursePageInput;
}

export interface CoursePageCreateInput {
  title: String;
  description: String;
  image: String;
  user: UserCreateOneWithoutCoursePagesInput;
  cases?: CaseCreateManyWithoutCoursePageInput;
  tests?: TestCreateManyWithoutCoursePageInput;
}

export interface CoursePageUpsertWithoutTestsInput {
  update: CoursePageUpdateWithoutTestsDataInput;
  create: CoursePageCreateWithoutTestsInput;
}

export interface CoursePageCreateManyWithoutUserInput {
  create?:
    | CoursePageCreateWithoutUserInput[]
    | CoursePageCreateWithoutUserInput;
  connect?: CoursePageWhereUniqueInput[] | CoursePageWhereUniqueInput;
}

export interface TestUpsertWithWhereUniqueWithoutUserInput {
  where: TestWhereUniqueInput;
  update: TestUpdateWithoutUserDataInput;
  create: TestCreateWithoutUserInput;
}

export interface SandboxPageCreateManyWithoutUserInput {
  create?:
    | SandboxPageCreateWithoutUserInput[]
    | SandboxPageCreateWithoutUserInput;
  connect?: SandboxPageWhereUniqueInput[] | SandboxPageWhereUniqueInput;
}

export interface UserUpsertWithoutCoursePagesInput {
  update: UserUpdateWithoutCoursePagesDataInput;
  create: UserCreateWithoutCoursePagesInput;
}

export interface TestSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TestWhereInput;
  AND?: TestSubscriptionWhereInput[] | TestSubscriptionWhereInput;
  OR?: TestSubscriptionWhereInput[] | TestSubscriptionWhereInput;
  NOT?: TestSubscriptionWhereInput[] | TestSubscriptionWhereInput;
}

export interface CoursePageUpsertWithoutCasesInput {
  update: CoursePageUpdateWithoutCasesDataInput;
  create: CoursePageCreateWithoutCasesInput;
}

export interface SandboxPageUpdateWithoutSandboxesDataInput {
  title?: String;
  description?: String;
  image?: String;
  user?: UserUpdateOneRequiredWithoutSandboxPagesInput;
}

export interface SandboxPageUpsertWithWhereUniqueWithoutUserInput {
  where: SandboxPageWhereUniqueInput;
  update: SandboxPageUpdateWithoutUserDataInput;
  create: SandboxPageCreateWithoutUserInput;
}

export interface SandboxUpsertWithWhereUniqueWithoutSandboxPageInput {
  where: SandboxWhereUniqueInput;
  update: SandboxUpdateWithoutSandboxPageDataInput;
  create: SandboxCreateWithoutSandboxPageInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface CaseUpsertWithWhereUniqueWithoutUserInput {
  where: CaseWhereUniqueInput;
  update: CaseUpdateWithoutUserDataInput;
  create: CaseCreateWithoutUserInput;
}

export interface SandboxPageCreateOneWithoutSandboxesInput {
  create?: SandboxPageCreateWithoutSandboxesInput;
  connect?: SandboxPageWhereUniqueInput;
}

export interface SandboxPageUpdateInput {
  title?: String;
  description?: String;
  image?: String;
  user?: UserUpdateOneRequiredWithoutSandboxPagesInput;
  sandboxes?: SandboxUpdateManyWithoutSandboxPageInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface TestCreateManyWithoutCoursePageInput {
  create?:
    | TestCreateWithoutCoursePageInput[]
    | TestCreateWithoutCoursePageInput;
  connect?: TestWhereUniqueInput[] | TestWhereUniqueInput;
}

export interface CaseCreateInput {
  title: String;
  description: String;
  mainText?: String;
  issue?: String;
  rule?: String;
  analysis?: String;
  conclusion?: String;
  image?: String;
  largeImage?: String;
  price?: Int;
  user: UserCreateOneWithoutCasesInput;
  coursePage: CoursePageCreateOneWithoutCasesInput;
  coursePageID: ID_Input;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValuesNode {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions: Permission[];
  isFamiliar: Boolean;
}

export interface UserPreviousValues
  extends Promise<UserPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  permissions: () => Promise<Permission[]>;
  isFamiliar: () => Promise<Boolean>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  permissions: () => Promise<AsyncIterator<Permission[]>>;
  isFamiliar: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateCaseNode {
  count: Int;
}

export interface AggregateCase
  extends Promise<AggregateCaseNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCaseSubscription
  extends Promise<AsyncIterator<AggregateCaseNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TestSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TestSubscriptionPayload
  extends Promise<TestSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Test>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TestPreviousValues>() => T;
}

export interface TestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TestSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TestPreviousValuesSubscription>() => T;
}

export interface CaseEdgeNode {
  cursor: String;
}

export interface CaseEdge extends Promise<CaseEdgeNode>, Fragmentable {
  node: <T = Case>() => T;
  cursor: () => Promise<String>;
}

export interface CaseEdgeSubscription
  extends Promise<AsyncIterator<CaseEdgeNode>>,
    Fragmentable {
  node: <T = CaseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfoNode {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfo extends Promise<PageInfoNode>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfoNode>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserNode {
  count: Int;
}

export interface AggregateUser
  extends Promise<AggregateUserNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUserNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayloadNode {
  count: Long;
}

export interface BatchPayload extends Promise<BatchPayloadNode>, Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayloadNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CaseConnectionNode {}

export interface CaseConnection
  extends Promise<CaseConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<CaseEdgeNode>>>() => T;
  aggregate: <T = AggregateCase>() => T;
}

export interface CaseConnectionSubscription
  extends Promise<AsyncIterator<CaseConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<CaseEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateCaseSubscription>() => T;
}

export interface UserConnectionNode {}

export interface UserConnection
  extends Promise<UserConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<UserEdgeNode>>>() => T;
  aggregate: <T = AggregateUser>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<UserEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface SandboxNode {
  id: ID_Output;
  text: String;
  sandboxPageID: ID_Output;
}

export interface Sandbox extends Promise<SandboxNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  user: <T = User>() => T;
  sandboxPage: <T = SandboxPage>() => T;
  sandboxPageID: () => Promise<ID_Output>;
}

export interface SandboxSubscription
  extends Promise<AsyncIterator<SandboxNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  sandboxPage: <T = SandboxPageSubscription>() => T;
  sandboxPageID: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateTestNode {
  count: Int;
}

export interface AggregateTest
  extends Promise<AggregateTestNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTestSubscription
  extends Promise<AsyncIterator<AggregateTestNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TestPreviousValuesNode {
  id: ID_Output;
  question: String;
  answer1: String;
  answer1Correct: String;
  answer2: String;
  answer2Correct: String;
  answer3?: String;
  answer3Correct?: String;
  answer4?: String;
  answer4Correct?: String;
  coursePageID: ID_Output;
}

export interface TestPreviousValues
  extends Promise<TestPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  question: () => Promise<String>;
  answer1: () => Promise<String>;
  answer1Correct: () => Promise<String>;
  answer2: () => Promise<String>;
  answer2Correct: () => Promise<String>;
  answer3: () => Promise<String>;
  answer3Correct: () => Promise<String>;
  answer4: () => Promise<String>;
  answer4Correct: () => Promise<String>;
  coursePageID: () => Promise<ID_Output>;
}

export interface TestPreviousValuesSubscription
  extends Promise<AsyncIterator<TestPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  question: () => Promise<AsyncIterator<String>>;
  answer1: () => Promise<AsyncIterator<String>>;
  answer1Correct: () => Promise<AsyncIterator<String>>;
  answer2: () => Promise<AsyncIterator<String>>;
  answer2Correct: () => Promise<AsyncIterator<String>>;
  answer3: () => Promise<AsyncIterator<String>>;
  answer3Correct: () => Promise<AsyncIterator<String>>;
  answer4: () => Promise<AsyncIterator<String>>;
  answer4Correct: () => Promise<AsyncIterator<String>>;
  coursePageID: () => Promise<AsyncIterator<ID_Output>>;
}

export interface TestConnectionNode {}

export interface TestConnection
  extends Promise<TestConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<TestEdgeNode>>>() => T;
  aggregate: <T = AggregateTest>() => T;
}

export interface TestConnectionSubscription
  extends Promise<AsyncIterator<TestConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<TestEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateTestSubscription>() => T;
}

export interface CaseNode {
  id: ID_Output;
  title: String;
  description: String;
  mainText?: String;
  issue?: String;
  rule?: String;
  analysis?: String;
  conclusion?: String;
  image?: String;
  largeImage?: String;
  price?: Int;
  coursePageID: ID_Output;
}

export interface Case extends Promise<CaseNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  mainText: () => Promise<String>;
  issue: () => Promise<String>;
  rule: () => Promise<String>;
  analysis: () => Promise<String>;
  conclusion: () => Promise<String>;
  image: () => Promise<String>;
  largeImage: () => Promise<String>;
  price: () => Promise<Int>;
  user: <T = User>() => T;
  coursePage: <T = CoursePage>() => T;
  coursePageID: () => Promise<ID_Output>;
}

export interface CaseSubscription
  extends Promise<AsyncIterator<CaseNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  mainText: () => Promise<AsyncIterator<String>>;
  issue: () => Promise<AsyncIterator<String>>;
  rule: () => Promise<AsyncIterator<String>>;
  analysis: () => Promise<AsyncIterator<String>>;
  conclusion: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  largeImage: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Int>>;
  user: <T = UserSubscription>() => T;
  coursePage: <T = CoursePageSubscription>() => T;
  coursePageID: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SandboxPageEdgeNode {
  cursor: String;
}

export interface SandboxPageEdge
  extends Promise<SandboxPageEdgeNode>,
    Fragmentable {
  node: <T = SandboxPage>() => T;
  cursor: () => Promise<String>;
}

export interface SandboxPageEdgeSubscription
  extends Promise<AsyncIterator<SandboxPageEdgeNode>>,
    Fragmentable {
  node: <T = SandboxPageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CaseSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CaseSubscriptionPayload
  extends Promise<CaseSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Case>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CasePreviousValues>() => T;
}

export interface CaseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CaseSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CaseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CasePreviousValuesSubscription>() => T;
}

export interface AggregateSandboxNode {
  count: Int;
}

export interface AggregateSandbox
  extends Promise<AggregateSandboxNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSandboxSubscription
  extends Promise<AsyncIterator<AggregateSandboxNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CasePreviousValuesNode {
  id: ID_Output;
  title: String;
  description: String;
  mainText?: String;
  issue?: String;
  rule?: String;
  analysis?: String;
  conclusion?: String;
  image?: String;
  largeImage?: String;
  price?: Int;
  coursePageID: ID_Output;
}

export interface CasePreviousValues
  extends Promise<CasePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  mainText: () => Promise<String>;
  issue: () => Promise<String>;
  rule: () => Promise<String>;
  analysis: () => Promise<String>;
  conclusion: () => Promise<String>;
  image: () => Promise<String>;
  largeImage: () => Promise<String>;
  price: () => Promise<Int>;
  coursePageID: () => Promise<ID_Output>;
}

export interface CasePreviousValuesSubscription
  extends Promise<AsyncIterator<CasePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  mainText: () => Promise<AsyncIterator<String>>;
  issue: () => Promise<AsyncIterator<String>>;
  rule: () => Promise<AsyncIterator<String>>;
  analysis: () => Promise<AsyncIterator<String>>;
  conclusion: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  largeImage: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Int>>;
  coursePageID: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SandboxConnectionNode {}

export interface SandboxConnection
  extends Promise<SandboxConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<SandboxEdgeNode>>>() => T;
  aggregate: <T = AggregateSandbox>() => T;
}

export interface SandboxConnectionSubscription
  extends Promise<AsyncIterator<SandboxConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<SandboxEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateSandboxSubscription>() => T;
}

export interface SandboxPageNode {
  id: ID_Output;
  title: String;
  description: String;
  image: String;
}

export interface SandboxPage extends Promise<SandboxPageNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  user: <T = User>() => T;
  sandboxes: <T = Promise<Array<SandboxNode>>>(
    args?: {
      where?: SandboxWhereInput;
      orderBy?: SandboxOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SandboxPageSubscription
  extends Promise<AsyncIterator<SandboxPageNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  sandboxes: <T = Promise<AsyncIterator<Array<SandboxSubscription>>>>(
    args?: {
      where?: SandboxWhereInput;
      orderBy?: SandboxOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CoursePageEdgeNode {
  cursor: String;
}

export interface CoursePageEdge
  extends Promise<CoursePageEdgeNode>,
    Fragmentable {
  node: <T = CoursePage>() => T;
  cursor: () => Promise<String>;
}

export interface CoursePageEdgeSubscription
  extends Promise<AsyncIterator<CoursePageEdgeNode>>,
    Fragmentable {
  node: <T = CoursePageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CoursePageSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CoursePageSubscriptionPayload
  extends Promise<CoursePageSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CoursePage>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CoursePagePreviousValues>() => T;
}

export interface CoursePageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CoursePageSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CoursePageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CoursePagePreviousValuesSubscription>() => T;
}

export interface UserEdgeNode {
  cursor: String;
}

export interface UserEdge extends Promise<UserEdgeNode>, Fragmentable {
  node: <T = User>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdgeNode>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CoursePagePreviousValuesNode {
  id: ID_Output;
  title: String;
  description: String;
  image: String;
}

export interface CoursePagePreviousValues
  extends Promise<CoursePagePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
}

export interface CoursePagePreviousValuesSubscription
  extends Promise<AsyncIterator<CoursePagePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
}

export interface CoursePageNode {
  id: ID_Output;
  title: String;
  description: String;
  image: String;
}

export interface CoursePage extends Promise<CoursePageNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  user: <T = User>() => T;
  cases: <T = Promise<Array<CaseNode>>>(
    args?: {
      where?: CaseWhereInput;
      orderBy?: CaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tests: <T = Promise<Array<TestNode>>>(
    args?: {
      where?: TestWhereInput;
      orderBy?: TestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CoursePageSubscription
  extends Promise<AsyncIterator<CoursePageNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  cases: <T = Promise<AsyncIterator<Array<CaseSubscription>>>>(
    args?: {
      where?: CaseWhereInput;
      orderBy?: CaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tests: <T = Promise<AsyncIterator<Array<TestSubscription>>>>(
    args?: {
      where?: TestWhereInput;
      orderBy?: TestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserNode {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  resetToken?: String;
  resetTokenExpiry?: Float;
  permissions: Permission[];
  isFamiliar: Boolean;
}

export interface User extends Promise<UserNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  permissions: () => Promise<Permission[]>;
  coursePages: <T = Promise<Array<CoursePageNode>>>(
    args?: {
      where?: CoursePageWhereInput;
      orderBy?: CoursePageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sandboxPages: <T = Promise<Array<SandboxPageNode>>>(
    args?: {
      where?: SandboxPageWhereInput;
      orderBy?: SandboxPageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cases: <T = Promise<Array<CaseNode>>>(
    args?: {
      where?: CaseWhereInput;
      orderBy?: CaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tests: <T = Promise<Array<TestNode>>>(
    args?: {
      where?: TestWhereInput;
      orderBy?: TestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  isFamiliar: () => Promise<Boolean>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<UserNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  permissions: () => Promise<AsyncIterator<Permission[]>>;
  coursePages: <T = Promise<AsyncIterator<Array<CoursePageSubscription>>>>(
    args?: {
      where?: CoursePageWhereInput;
      orderBy?: CoursePageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sandboxPages: <T = Promise<AsyncIterator<Array<SandboxPageSubscription>>>>(
    args?: {
      where?: SandboxPageWhereInput;
      orderBy?: SandboxPageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cases: <T = Promise<AsyncIterator<Array<CaseSubscription>>>>(
    args?: {
      where?: CaseWhereInput;
      orderBy?: CaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tests: <T = Promise<AsyncIterator<Array<TestSubscription>>>>(
    args?: {
      where?: TestWhereInput;
      orderBy?: TestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  isFamiliar: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateSandboxPageNode {
  count: Int;
}

export interface AggregateSandboxPage
  extends Promise<AggregateSandboxPageNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSandboxPageSubscription
  extends Promise<AsyncIterator<AggregateSandboxPageNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SandboxSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface SandboxSubscriptionPayload
  extends Promise<SandboxSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Sandbox>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SandboxPreviousValues>() => T;
}

export interface SandboxSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SandboxSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SandboxSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SandboxPreviousValuesSubscription>() => T;
}

export interface SandboxEdgeNode {
  cursor: String;
}

export interface SandboxEdge extends Promise<SandboxEdgeNode>, Fragmentable {
  node: <T = Sandbox>() => T;
  cursor: () => Promise<String>;
}

export interface SandboxEdgeSubscription
  extends Promise<AsyncIterator<SandboxEdgeNode>>,
    Fragmentable {
  node: <T = SandboxSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CoursePageConnectionNode {}

export interface CoursePageConnection
  extends Promise<CoursePageConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<CoursePageEdgeNode>>>() => T;
  aggregate: <T = AggregateCoursePage>() => T;
}

export interface CoursePageConnectionSubscription
  extends Promise<AsyncIterator<CoursePageConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<CoursePageEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateCoursePageSubscription>() => T;
}

export interface SandboxPagePreviousValuesNode {
  id: ID_Output;
  title: String;
  description: String;
  image: String;
}

export interface SandboxPagePreviousValues
  extends Promise<SandboxPagePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
}

export interface SandboxPagePreviousValuesSubscription
  extends Promise<AsyncIterator<SandboxPagePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
}

export interface SandboxPageSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface SandboxPageSubscriptionPayload
  extends Promise<SandboxPageSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SandboxPage>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SandboxPagePreviousValues>() => T;
}

export interface SandboxPageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SandboxPageSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SandboxPageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SandboxPagePreviousValuesSubscription>() => T;
}

export interface TestNode {
  id: ID_Output;
  question: String;
  answer1: String;
  answer1Correct: String;
  answer2: String;
  answer2Correct: String;
  answer3?: String;
  answer3Correct?: String;
  answer4?: String;
  answer4Correct?: String;
  coursePageID: ID_Output;
}

export interface Test extends Promise<TestNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  question: () => Promise<String>;
  answer1: () => Promise<String>;
  answer1Correct: () => Promise<String>;
  answer2: () => Promise<String>;
  answer2Correct: () => Promise<String>;
  answer3: () => Promise<String>;
  answer3Correct: () => Promise<String>;
  answer4: () => Promise<String>;
  answer4Correct: () => Promise<String>;
  user: <T = User>() => T;
  coursePage: <T = CoursePage>() => T;
  coursePageID: () => Promise<ID_Output>;
}

export interface TestSubscription
  extends Promise<AsyncIterator<TestNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  question: () => Promise<AsyncIterator<String>>;
  answer1: () => Promise<AsyncIterator<String>>;
  answer1Correct: () => Promise<AsyncIterator<String>>;
  answer2: () => Promise<AsyncIterator<String>>;
  answer2Correct: () => Promise<AsyncIterator<String>>;
  answer3: () => Promise<AsyncIterator<String>>;
  answer3Correct: () => Promise<AsyncIterator<String>>;
  answer4: () => Promise<AsyncIterator<String>>;
  answer4Correct: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  coursePage: <T = CoursePageSubscription>() => T;
  coursePageID: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SandboxPreviousValuesNode {
  id: ID_Output;
  text: String;
  sandboxPageID: ID_Output;
}

export interface SandboxPreviousValues
  extends Promise<SandboxPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  sandboxPageID: () => Promise<ID_Output>;
}

export interface SandboxPreviousValuesSubscription
  extends Promise<AsyncIterator<SandboxPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  sandboxPageID: () => Promise<AsyncIterator<ID_Output>>;
}

export interface UserSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayload
  extends Promise<UserSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = User>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValues>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AggregateCoursePageNode {
  count: Int;
}

export interface AggregateCoursePage
  extends Promise<AggregateCoursePageNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCoursePageSubscription
  extends Promise<AsyncIterator<AggregateCoursePageNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SandboxPageConnectionNode {}

export interface SandboxPageConnection
  extends Promise<SandboxPageConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<SandboxPageEdgeNode>>>() => T;
  aggregate: <T = AggregateSandboxPage>() => T;
}

export interface SandboxPageConnectionSubscription
  extends Promise<AsyncIterator<SandboxPageConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<Array<SandboxPageEdgeSubscription>>>
  >() => T;
  aggregate: <T = AggregateSandboxPageSubscription>() => T;
}

export interface TestEdgeNode {
  cursor: String;
}

export interface TestEdge extends Promise<TestEdgeNode>, Fragmentable {
  node: <T = Test>() => T;
  cursor: () => Promise<String>;
}

export interface TestEdgeSubscription
  extends Promise<AsyncIterator<TestEdgeNode>>,
    Fragmentable {
  node: <T = TestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/**
 * Type Defs
 */

export const prisma: Prisma;
